#include <assert.h>

// SDL3

#define SDL_MAIN_USE_CALLBACKS 1
#include <SDL3/SDL.h>
#include <SDL3/SDL_main.h>

// fast_obj

#define FAST_OBJ_IMPLEMENTATION
#include <fast_obj.h>

// MikkTSpace

#include <mikktspace.h>

// The-Forge

#include <Graphics/Interfaces/IGraphics.h>
#include <Utilities/Interfaces/IFileSystem.h>
#include <Utilities/Interfaces/ILog.h>
#include <Utilities/Interfaces/IMemory.h>
#include <Utilities/RingBuffer.h>

extern "C"
{
	__declspec(dllexport) extern const UINT D3D12SDKVersion = 715;
	__declspec(dllexport) extern const char* D3D12SDKPath = "";
}

// Shader Interop

#include <ShaderGlobals.h>

static inline void loadMat4(const ::mat4& matrix, float* output);

struct Timer
{
	uint64_t lastTicks = 0;
	float deltaTime = 0.0f;

	void Tick()
	{
		uint64_t ticks = SDL_GetTicksNS();
		uint64_t deltaNS = ticks - lastTicks;
		deltaTime = (float)(deltaNS * 1e-9);
		lastTicks = ticks;
	}
};

struct PlayerCamera
{
	::mat4 viewMatrix;
	::float3 position;
	::float3 lookAt;
	
	::float3 getViewDir()
	{
		::mat4 transposed = ::transpose(viewMatrix);
		::Vector4 forward = -transposed.getCol2();
		return { forward.getX(), forward.getY(), forward.getZ() };
	}

	void updateViewMatrix()
	{
		viewMatrix = ::mat4::lookAtRH({ position.x, position.y, position.z }, { lookAt.x, lookAt.y, lookAt.z }, {0.0f, 0.0f, 1.0f});
	}
};

// TODO: These should be autogenerated with some codegen solution
// from the shader (source of bytecode reflections) 
// UberShader Descriptor Sets
struct SRT_UberShaderData
{
	struct Persistent
	{
		const ::Descriptor gLinearRepeatSampler =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gLinearRepeatSampler", ROOT_PARAM_Persistent_SAMPLER,
#endif
			::DESCRIPTOR_TYPE_SAMPLER, 1, 0
		};
	}* pPersistent;

	static const ::Descriptor* PersistentPtr()
	{
		if (!sizeof(Persistent))
		{
			return 0;
		}

		static Persistent layout = {};
		::Descriptor* desc = (::Descriptor*)((uint64_t)&layout);
		return &desc[0];
	}

	struct PerFrame
	{
		const ::Descriptor CB0 =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"CB0", ROOT_PARAM_PerFrame, 
#endif
			::DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1, 0
		};
	}* pPerFrame;

	static const ::Descriptor* PerFramePtr()
	{
		if (!sizeof(PerFrame))
		{
			return 0;
		}

		static PerFrame layout = {};
		::Descriptor* desc = (::Descriptor*)((uint64_t)&layout);
		return &desc[0];
	}
};

// TODO: These should be autogenerated with some codegen solution
// from the shader (source of bytecode reflections) 
// Tone Mapping Descriptor Sets
struct SRT_ToneMappingData
{
	struct Persistent
	{
		const ::Descriptor gLinearClampSampler =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gLinearClampSampler", ROOT_PARAM_Persistent_SAMPLER,
#endif
			::DESCRIPTOR_TYPE_SAMPLER, 1, 0
		};
	}*pPersistent;

	static const ::Descriptor* PersistentPtr()
	{
		if (!sizeof(Persistent))
		{
			return 0;
		}

		static Persistent layout = {};
		::Descriptor* desc = (::Descriptor*)((uint64_t)&layout);
		return &desc[0];
	}

	struct PerFrame
	{
		const ::Descriptor gSceneColor =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gSceneColor", ROOT_PARAM_PerFrame,
#endif
			::DESCRIPTOR_TYPE_TEXTURE, 1, 0
		};
		const ::Descriptor gTonyMcMapfaceLut =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gTonyMcMapfaceLut", ROOT_PARAM_PerFrame,
#endif
			::DESCRIPTOR_TYPE_TEXTURE, 1, 1
		};
		const ::Descriptor gBloomBuffer =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gBloomBuffer", ROOT_PARAM_PerFrame,
#endif
			::DESCRIPTOR_TYPE_TEXTURE, 1, 2
		};
	}*pPerFrame;

	static const ::Descriptor* PerFramePtr()
	{
		if (!sizeof(PerFrame))
		{
			return 0;
		}

		static PerFrame layout = {};
		::Descriptor* desc = (::Descriptor*)((uint64_t)&layout);
		return &desc[0];
	}
};

// TODO: These should be autogenerated with some codegen solution
// from the shader (source of bytecode reflections) 
// Downsample Descriptor Sets
struct SRT_DownsampleData
{
	struct Persistent
	{
		const ::Descriptor gLinearClampSampler =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gLinearClampSampler", ROOT_PARAM_Persistent_SAMPLER,
#endif
			::DESCRIPTOR_TYPE_SAMPLER, 1, 0
		};
	}*pPersistent;

	static const ::Descriptor* PersistentPtr()
	{
		if (!sizeof(Persistent))
		{
			return 0;
		}

		static Persistent layout = {};
		::Descriptor* desc = (::Descriptor*)((uint64_t)&layout);
		return &desc[0];
	}

	struct PerDraw
	{
		const ::Descriptor CB0 =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"CB0", ROOT_PARAM_PerDraw,
#endif
			::DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1, 0
		};
		const ::Descriptor gSourceTexture =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gSourceTexture", ROOT_PARAM_PerDraw,
#endif
			::DESCRIPTOR_TYPE_TEXTURE, 1, 1
		};
		const ::Descriptor gDestinationTexture =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gDestinationTexture", ROOT_PARAM_PerDraw,
#endif
			::DESCRIPTOR_TYPE_RW_TEXTURE, 1, 2
		};
	}*pPerDraw;

	static const ::Descriptor* PerDrawPtr()
	{
		if (!sizeof(PerDraw))
		{
			return 0;
		}

		static PerDraw layout = {};
		::Descriptor* desc = (::Descriptor*)((uint64_t)&layout);
		return &desc[0];
	}
};

// TODO: These should be autogenerated with some codegen solution
// from the shader (source of bytecode reflections) 
// Upsample Descriptor Sets
struct SRT_UpsampleData
{
	struct Persistent
	{
		const ::Descriptor gLinearClampSampler =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gLinearClampSampler", ROOT_PARAM_Persistent_SAMPLER,
#endif
			::DESCRIPTOR_TYPE_SAMPLER, 1, 0
		};
	}*pPersistent;

	static const ::Descriptor* PersistentPtr()
	{
		if (!sizeof(Persistent))
		{
			return 0;
		}

		static Persistent layout = {};
		::Descriptor* desc = (::Descriptor*)((uint64_t)&layout);
		return &desc[0];
	}

	struct PerDraw
	{
		const ::Descriptor CB0 =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"CB0", ROOT_PARAM_PerDraw,
#endif
			::DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1, 0
		};
		const ::Descriptor gSourceTexture =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gSourceTexture", ROOT_PARAM_PerDraw,
#endif
			::DESCRIPTOR_TYPE_TEXTURE, 1, 1
		};
		const ::Descriptor gPreviousTexture =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gPreviousTexture", ROOT_PARAM_PerDraw,
#endif
			::DESCRIPTOR_TYPE_TEXTURE, 1, 2
		};
		const ::Descriptor gDestinationTexture =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gDestinationTexture", ROOT_PARAM_PerDraw,
#endif
			::DESCRIPTOR_TYPE_RW_TEXTURE, 1, 3
		};
	}*pPerDraw;

	static const ::Descriptor* PerDrawPtr()
	{
		if (!sizeof(PerDraw))
		{
			return 0;
		}

		static PerDraw layout = {};
		::Descriptor* desc = (::Descriptor*)((uint64_t)&layout);
		return &desc[0];
	}
};

enum class Meshes
{
	Plane = 0,
	Cube = 1,
	DamagedHelmet = 2,

	_Count,
};

struct RendererGeometry
{
	MeshVertex* vertices = NULL;
	uint32_t* indices = NULL;

	uint32_t numVertices = 0;
	uint32_t numIndices = 0;
};
struct ScratchGeometryData
{
	RendererGeometry geometry = {};
	uint32_t maxVertices = 256 * 1024;
	uint32_t maxIndices = 1024 * 1024;

	bool isInitialized();
	void initialize();
	void reset();
	void destroy();
};

static ScratchGeometryData k_ScratchGeometryData;

const uint32_t kDataBufferCount = 2;
const uint32_t kDownsampleSteps = 8;
const uint32_t kUpsampleSteps = 7;

const uint32_t k_MaxMaterials = 1024;
const uint32_t k_MaxMeshes = 1024;
const uint32_t k_MaxInstances = 1024 * 1024;
const uint32_t k_MaxIndirectDrawIndexArgs = 1024;

struct GameState
{
	::float3 playerPosition;
	float playerMovementSpeed;
	::float2 playerMovementVector;
};

struct AppState
{
	SDL_Window* window = NULL;

	uint32_t frameIndex = 0;

	::Renderer* renderer = NULL;
	::Queue* graphicsQueue = NULL;
	::GpuCmdRing graphicsCmdRing = {};
	::SwapChain* swapChain = NULL;
	::Semaphore* imageAcquiredSemaphore = NULL;
	::RenderTarget* sceneColor = NULL;
	::RenderTarget* depthBuffer = NULL;

	::Buffer* downsampleUniformBuffers[kDownsampleSteps] = { NULL };
	::Buffer* upsampleUniformBuffers[kUpsampleSteps] = { NULL };
	::Texture* bloomDownsamples[kDownsampleSteps] = { NULL };
	::Texture* bloomUpsamples[kUpsampleSteps] = { NULL };

	RendererGeometry geometry = {};
	::Buffer* meshesBuffer = NULL;
	::Buffer* vertexBuffer = NULL;
	::Buffer* indexBuffer = NULL;

	::Buffer* frameUniformBuffers[kDataBufferCount] = { NULL };
	::Buffer* instanceBuffers[kDataBufferCount] = { NULL };
	::Buffer* materialBuffers[kDataBufferCount] = { NULL };
	::Buffer* lightBuffers[kDataBufferCount] = { NULL };
	::Buffer* indirectDrawBuffers[kDataBufferCount] = { NULL };
	
	GPUMesh* meshes = NULL;
	uint32_t numMeshes = 0;

	GPUInstance* instances = NULL;
	uint32_t numInstances = 0;

	GPUMaterial* materials = NULL;
	uint32_t numMaterials = 0;

	IndirectDrawIndexArguments* indirectDrawIndexArgs[kDataBufferCount] = { NULL };
	uint32_t maxIndirectDrawIndexArgs = 0;
	uint32_t numIndirectDrawIndexArgs[kDataBufferCount] = { 0 };

	GPULight* lights = NULL;
	uint32_t numLights = 0;

	// UberShader
	::Shader* uberShader = NULL;
	::Pipeline* uberPipeline = NULL;

	// Downsampling
	::Shader* downsampleShader = NULL;
	::Pipeline* downsamplePipeline = NULL;
	::DescriptorSet* downsamplePersistentDescriptorSet = NULL;
	::DescriptorSet* downsamplePerDrawDescriptorSet = NULL;

	// Upsampling
	::Shader* upsampleShader = NULL;
	::Pipeline* upsamplePipeline = NULL;
	::DescriptorSet* upsamplePersistentDescriptorSet = NULL;
	::DescriptorSet* upsamplePerDrawDescriptorSet = NULL;

	// Tonemapping
	::Shader* toneMapping = NULL;
	::Pipeline* toneMappingPipeline = NULL;
	::Texture* tonyMcMapfaceLUT = NULL;
	::DescriptorSet* toneMappingPersistentDescriptorSet = NULL;
	::DescriptorSet* toneMappingPerFrameDescriptorSet = NULL;

	::Sampler* linearRepeatSampler = NULL;
	::Sampler* linearClampSampler = NULL;

	// NOTE: This is the data of a specific material
	::DescriptorSet* uberPersistentDescriptorSet = NULL;
	::DescriptorSet* uberPerFrameDescriptorSet = NULL;

	// TODO(gmodarelli): Use a pool to store pointers to textures
	::Texture* damagedHelmetAlbedoTexture = NULL;
	::Texture* damagedHelmetNormalTexture = NULL;
	::Texture* damagedHelmetOrmTexture = NULL;
	::Texture* damagedHelmetEmissiveTexture = NULL;
	::Texture* gridAlbedoTexture = NULL;
	::Texture* gridOrmTexture = NULL;

	// Timer
	Timer timer;

	PlayerCamera playerCamera;

	// Sun
	::float3 sunDirection;
	::float3 sunColor;
	float sunIntensity;

	// Game State
	GameState gameState;
};

void game_UpdatePlayerMovement(AppState* appState);

bool renderer_Initialize(AppState* appState);
void renderer_Exit(AppState* appState);
bool renderer_OnLoad(AppState* appState, ReloadDesc reloadDesc);
void renderer_OnUnload(AppState* appState, ReloadDesc reloadDesc);
bool renderer_AddSwapChain(AppState* appState);
void renderer_RemoveSwapChain(AppState* appState);
bool renderer_AddRenderTargets(AppState* appState);
void renderer_RemoveRenderTargets(AppState* appState);
void renderer_Draw(AppState* appState);
void renderer_AddShaders(AppState* appState);
void renderer_RemoveShaders(AppState* appState);
void renderer_AddDescriptorSets(AppState* appState);
void renderer_PrepareDescriptorSets(AppState* appState);
void renderer_RemoveDescriptorSets(AppState* appState);
void renderer_AddPipelines(AppState* appState);
void renderer_RemovePipelines(AppState* appState);
void renderer_AddGeometry(AppState* appState);
void renderer_RemoveGeometry(AppState* appState);
void renderer_LoadMesh(RendererGeometry* geometry, const char* path, GPUMesh* mesh);

SDL_AppResult SDL_AppInit(void** appstate, int argc, char* argv[])
{
	AppState* as = (AppState*)SDL_calloc(1, sizeof(AppState));
	if (!as)
	{
		return SDL_APP_FAILURE;
	}

	memset(as, 0, sizeof(AppState));

	*appstate = as;
	
	as->gameState.playerPosition = { 0.0f, 0.0f, 0.0f };
	as->gameState.playerMovementVector = { 0.0f, 0.0f };
	as->gameState.playerMovementSpeed = 2.0f;

	as->playerCamera.position = { 0.0f, -10.0f, 10.0f };
	as->playerCamera.lookAt = { 0.0f, 0.0f, 0.0f };
	as->playerCamera.updateViewMatrix();

	as->sunDirection = { 1.0f, 0.0f, -1.0f };
	as->sunColor = ::srgbToLinearf3({ 1.0f, 1.0f, 1.0f });
	as->sunIntensity = 0.0f;

	as->window = SDL_CreateWindow("Prototype 0", 1920, 1080, SDL_WINDOW_RESIZABLE);
	if (!as->window)
	{
		SDL_Log("Couldn't create window: %s", SDL_GetError());
		return SDL_APP_FAILURE;
	}

	if (!renderer_Initialize(as))
	{
		return SDL_APP_FAILURE;
	}
	
	SDL_Log("Initialized");
	return SDL_APP_CONTINUE;
}

SDL_AppResult SDL_AppEvent(void* appstate, SDL_Event* event)
{
    if (event->type == SDL_EVENT_QUIT)
    {
        return SDL_APP_SUCCESS;
    }

	AppState* as = (AppState*)appstate;

	if (event->type == SDL_EVENT_WINDOW_RESIZED)
	{
		renderer_OnUnload(as, { ::RELOAD_TYPE_RESIZE });
		renderer_OnLoad(as, { ::RELOAD_TYPE_RESIZE });
	}

	if (event->type == SDL_EVENT_KEY_DOWN)
	{
		if (event->key.key == SDLK_R)
		{
			renderer_OnUnload(as, { ::RELOAD_TYPE_SHADER });
			renderer_OnLoad(as, { ::RELOAD_TYPE_SHADER });
		}

		if (event->key.key == SDLK_P)
		{
			as->sunIntensity += 0.1f;
			as->sunIntensity = as->sunIntensity > 10.0f ? 10.0f : as->sunIntensity;
		}

		if (event->key.key == SDLK_O)
		{
			as->sunIntensity -= 0.1f;
			as->sunIntensity = as->sunIntensity < 0.0f ? 0.0f : as->sunIntensity;
		}

		if (event->key.key == SDLK_A)
		{
			as->gameState.playerMovementVector.x = -1.0f;
		}
		if (event->key.key == SDLK_D)
		{
			as->gameState.playerMovementVector.x = 1.0f;
		}
		if (event->key.key == SDLK_W)
		{
			as->gameState.playerMovementVector.y = 1.0f;
		}
		if (event->key.key == SDLK_S)
		{
			as->gameState.playerMovementVector.y = -1.0f;
		}
	}

	if (event->type == SDL_EVENT_KEY_UP)
	{
		if (event->key.key == SDLK_A)
		{
			if (as->gameState.playerMovementVector.x < 0)
				as->gameState.playerMovementVector.x = 0.0f;
		}
		if (event->key.key == SDLK_D)
		{
			if (as->gameState.playerMovementVector.x > 0)
				as->gameState.playerMovementVector.x = 0.0f;
		}
		if (event->key.key == SDLK_W)
		{
			if (as->gameState.playerMovementVector.y > 0)
				as->gameState.playerMovementVector.y = 0.0f;
		}
		if (event->key.key == SDLK_S)
		{
			if (as->gameState.playerMovementVector.y < 0)
				as->gameState.playerMovementVector.y = 0.0f;
		}
	}

    return SDL_APP_CONTINUE;
}

SDL_AppResult SDL_AppIterate(void* appstate)
{
	AppState* as = (AppState*)appstate;
	as->timer.Tick();

	game_UpdatePlayerMovement(as);

	renderer_Draw(as);

    return SDL_APP_CONTINUE;
}

void SDL_AppQuit(void* appstate, SDL_AppResult result)
{
	if (appstate != NULL)
	{
		AppState* as = (AppState*)appstate;
		renderer_Exit(as);

		SDL_free(as);
	}
}

void game_UpdatePlayerMovement(AppState* appState)
{
	GameState* gameState = &appState->gameState;
	if (gameState->playerMovementVector.x != 0 || gameState->playerMovementVector.y != 0)
	{
		gameState->playerMovementVector = ::normalize(gameState->playerMovementVector);
	}

	::float2 positionOffset = {
		gameState->playerMovementVector.x * gameState->playerMovementSpeed * appState->timer.deltaTime,
		gameState->playerMovementVector.y * gameState->playerMovementSpeed * appState->timer.deltaTime
	};

	gameState->playerPosition.x += positionOffset.x;
	gameState->playerPosition.y += positionOffset.y;
	gameState->playerPosition.z = 1.0f;

	appState->playerCamera.position.x = gameState->playerPosition.x;
	appState->playerCamera.position.y += positionOffset.y;
	appState->playerCamera.lookAt = gameState->playerPosition;
	appState->playerCamera.updateViewMatrix();
}

bool renderer_Initialize(AppState* appState)
{
	if (!appState)
	{
		SDL_Log("AppState has not been initialized");
		return false;
	}

	// Initialize Memory Allocation System
	{
		if (!::initMemAlloc("Prototype 0"))
		{
			SDL_Log("Couldn't initialize The-Forge Memory Allocation system");
			return false;
		}
	}

	// Initialize The-Forge File System
	{
		FileSystemInitDesc desc = FileSystemInitDesc{};
		desc.pAppName = "Prototype 0";
		if (!::initFileSystem(&desc))
		{
			SDL_Log("Couldn't initialize The-Forge File system");
			return false;
		}
	}

	// Initialize The-Forge Logging System
	{
		::initLog("Prototype 0", LogLevel::eALL);
	}

	// Initialize The-Forge Renderer
	{
		::RendererDesc desc = RendererDesc{};
		memset((void*)&desc, 0, sizeof(RendererDesc));
		desc.mShaderTarget = ::SHADER_TARGET_6_8;
		::initGPUConfiguration(desc.pExtendedSettings);

		::initRenderer("Prototype 0", &desc, &appState->renderer);
		if (!appState->renderer)
		{
			SDL_Log("Couldn't initialize The-Forge Renderer");
			return false;
		}

		::setupGPUConfigurationPlatformParameters(appState->renderer, desc.pExtendedSettings);
	}

	// Initialize Graphics Queue
	{
		::QueueDesc queueDesc = {};
		queueDesc.mType = ::QUEUE_TYPE_GRAPHICS;
		queueDesc.mFlag = ::QUEUE_FLAG_INIT_MICROPROFILE;
		::initQueue(appState->renderer, &queueDesc, &appState->graphicsQueue);

		::GpuCmdRingDesc cmdRingDesc = {};
		cmdRingDesc.pQueue = appState->graphicsQueue;
		cmdRingDesc.mPoolCount = kDataBufferCount;
		cmdRingDesc.mCmdPerPoolCount = 1;
		cmdRingDesc.mAddSyncPrimitives = true;
		::initGpuCmdRing(appState->renderer, &cmdRingDesc, &appState->graphicsCmdRing);

		::initSemaphore(appState->renderer, &appState->imageAcquiredSemaphore);
	}

	::initResourceLoaderInterface(appState->renderer);

	::RootSignatureDesc rootDesc = {};
	rootDesc.pGraphicsFileName = "DefaultRootSignature.rs";
	rootDesc.pComputeFileName = "ComputeRootSignature.rs";
	::initRootSignature(appState->renderer, &rootDesc);

	// Static samplers
	{
		::SamplerDesc samplerDesc = {
			::FILTER_LINEAR,
			::FILTER_LINEAR,
			::MIPMAP_MODE_LINEAR,
			::ADDRESS_MODE_REPEAT,
			::ADDRESS_MODE_REPEAT,
			::ADDRESS_MODE_REPEAT,
		};
		::addSampler(appState->renderer, &samplerDesc, &appState->linearRepeatSampler);

		samplerDesc.mAddressU = ::ADDRESS_MODE_CLAMP_TO_EDGE;
		samplerDesc.mAddressV = ::ADDRESS_MODE_CLAMP_TO_EDGE;
		samplerDesc.mAddressW = ::ADDRESS_MODE_CLAMP_TO_EDGE;
		::addSampler(appState->renderer, &samplerDesc, &appState->linearClampSampler);
	}

	// Frame uniform buffers
	{
		::BufferLoadDesc ubDesc = {};
		ubDesc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_UNIFORM_BUFFER;
		ubDesc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_CPU_TO_GPU;
		ubDesc.mDesc.mFlags = ::BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT;
		ubDesc.mDesc.pName = "Frame Uniform Buffer";
		ubDesc.mDesc.mSize = sizeof(Frame);
		ubDesc.pData = NULL;
		for (uint32_t i = 0; i < kDataBufferCount; ++i)
		{
			ubDesc.ppBuffer = &appState->frameUniformBuffers[i];
			::addResource(&ubDesc, NULL);
		}
	}

	// Downsample uniform buffers
	{
		::BufferLoadDesc ubDesc = {};
		ubDesc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_UNIFORM_BUFFER;
		ubDesc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_CPU_TO_GPU;
		ubDesc.mDesc.mFlags = ::BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT;
		ubDesc.mDesc.pName = "Downsample Uniform Buffer";
		ubDesc.mDesc.mSize = sizeof(DownsampleUniform);
		ubDesc.pData = NULL;
		for (uint32_t i = 0; i < kDownsampleSteps; ++i)
		{
			ubDesc.ppBuffer = &appState->downsampleUniformBuffers[i];
			::addResource(&ubDesc, NULL);
		}
	}

	// Downsample uniform buffers
	{
		::BufferLoadDesc ubDesc = {};
		ubDesc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_UNIFORM_BUFFER;
		ubDesc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_CPU_TO_GPU;
		ubDesc.mDesc.mFlags = ::BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT;
		ubDesc.mDesc.pName = "Upsample Uniform Buffer";
		ubDesc.mDesc.mSize = sizeof(UpsampleUniform);
		ubDesc.pData = NULL;
		for (uint32_t i = 0; i < kUpsampleSteps; ++i)
		{
			ubDesc.ppBuffer = &appState->upsampleUniformBuffers[i];
			::addResource(&ubDesc, NULL);
		}
	}

	// Load Tony McMapface LUT
	{
		::SyncToken texturesToken = NULL;

		::TextureLoadDesc textureLoadDesc = {};
		memset(&textureLoadDesc, 0, sizeof(::TextureLoadDesc));

		::TextureDesc textureDesc = {};
		memset(&textureDesc, 0, sizeof(::TextureDesc));
		textureDesc.bBindless = false;
		textureLoadDesc.pDesc = &textureDesc;

		textureLoadDesc.pFileName = "Textures/tony_mc_mapface.dds";
		textureLoadDesc.ppTexture = &appState->tonyMcMapfaceLUT;
		::addResource(&textureLoadDesc, &texturesToken);

		::waitForToken(&texturesToken);
	}

	// Geometry
	renderer_AddGeometry(appState);

	// Temporary instances, materials and lights
	{
		// Materials
		{
			// Load PBR Textures
			{
				::SyncToken texturesToken = NULL;

				::TextureLoadDesc textureLoadDesc = {};
				memset(&textureLoadDesc, 0, sizeof(::TextureLoadDesc));

				::TextureDesc textureDesc = {};
				memset(&textureDesc, 0, sizeof(::TextureDesc));
				textureDesc.bBindless = true;
				textureLoadDesc.pDesc = &textureDesc;

				textureLoadDesc.pFileName = "Models/DamagedHelmet_albedo.dds";
				textureLoadDesc.ppTexture = &appState->damagedHelmetAlbedoTexture;
				::addResource(&textureLoadDesc, &texturesToken);

				textureLoadDesc.pFileName = "Models/DamagedHelmet_normal.dds";
				textureLoadDesc.ppTexture = &appState->damagedHelmetNormalTexture;
				::addResource(&textureLoadDesc, &texturesToken);

				textureLoadDesc.pFileName = "Models/DamagedHelmet_orm.dds";
				textureLoadDesc.ppTexture = &appState->damagedHelmetOrmTexture;
				::addResource(&textureLoadDesc, &texturesToken);

				textureLoadDesc.pFileName = "Models/DamagedHelmet_emissive.dds";
				textureLoadDesc.ppTexture = &appState->damagedHelmetEmissiveTexture;
				::addResource(&textureLoadDesc, &texturesToken);

				textureLoadDesc.pFileName = "Textures/Debug/Grid_albedo.dds";
				textureLoadDesc.ppTexture = &appState->gridAlbedoTexture;
				::addResource(&textureLoadDesc, &texturesToken);

				textureLoadDesc.pFileName = "Textures/Debug/Grid_orm.dds";
				textureLoadDesc.ppTexture = &appState->gridOrmTexture;
				::addResource(&textureLoadDesc, &texturesToken);

				::waitForToken(&texturesToken);
			}

			appState->materials = (GPUMaterial*)tf_malloc(sizeof(GPUMaterial) * k_MaxMaterials);
			assert(appState->materials);
			memset(appState->materials, 0, sizeof(GPUMaterial) * k_MaxMaterials);

			GPUMaterial& playerMaterial = appState->materials[appState->numMaterials++];
			playerMaterial.baseColor = { 0.8f, 0.8f, 0.8f, 1.0f };
			playerMaterial.normalIntensity = 1.0f;
			playerMaterial.occlusionFactor = 1.0f;
			playerMaterial.roughnessFactor = 0.8f;
			playerMaterial.metalnessFactor = 0.0f;
			playerMaterial.emissiveFactor = 0.0f;
			playerMaterial.reflectance = 0.5f;
			playerMaterial.uv0Tiling = { 1.0f, 1.0f };
			playerMaterial.albedoTextureIndex = INVALID_BINDLESS_INDEX;
			playerMaterial.normalTextureIndex = INVALID_BINDLESS_INDEX;
			playerMaterial.ormTextureIndex = INVALID_BINDLESS_INDEX;
			playerMaterial.emissiveTextureIndex = INVALID_BINDLESS_INDEX;

			GPUMaterial& gridMaterial = appState->materials[appState->numMaterials++];
			gridMaterial.baseColor = { 1.0f, 1.0f, 1.0f, 1.0f };
			gridMaterial.normalIntensity = 1.0f;
			gridMaterial.occlusionFactor = 1.0f;
			gridMaterial.roughnessFactor = 1.0f;
			gridMaterial.metalnessFactor = 0.0f;
			gridMaterial.emissiveFactor = 0.0f;
			gridMaterial.reflectance = 0.5f;
			gridMaterial.uv0Tiling = { 1.0f, 1.0f };
			gridMaterial.albedoTextureIndex = appState->gridAlbedoTexture->mDx.mDescriptors;
			gridMaterial.normalTextureIndex = INVALID_BINDLESS_INDEX;
			gridMaterial.ormTextureIndex = appState->gridOrmTexture->mDx.mDescriptors;
			gridMaterial.emissiveTextureIndex = INVALID_BINDLESS_INDEX;

			GPUMaterial& damagedHelmetMaterial = appState->materials[appState->numMaterials++];
			damagedHelmetMaterial.baseColor = { 1.0f, 1.0f, 1.0f, 1.0f };
			damagedHelmetMaterial.normalIntensity = 1.0f;
			damagedHelmetMaterial.occlusionFactor = 1.0f;
			damagedHelmetMaterial.roughnessFactor = 1.0f;
			damagedHelmetMaterial.metalnessFactor = 0.0f;
			damagedHelmetMaterial.emissiveFactor = 2.0f;
			damagedHelmetMaterial.reflectance = 0.5f;
			damagedHelmetMaterial.uv0Tiling = { 1.0f, 1.0f };
			damagedHelmetMaterial.albedoTextureIndex = appState->damagedHelmetAlbedoTexture->mDx.mDescriptors;
			damagedHelmetMaterial.normalTextureIndex = appState->damagedHelmetNormalTexture->mDx.mDescriptors;
			damagedHelmetMaterial.ormTextureIndex = appState->damagedHelmetOrmTexture->mDx.mDescriptors;
			damagedHelmetMaterial.emissiveTextureIndex = appState->damagedHelmetEmissiveTexture->mDx.mDescriptors;

			::BufferLoadDesc desc = {};
			desc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_BUFFER_RAW;
			desc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_GPU_ONLY;
			desc.mDesc.mFlags = ::BUFFER_CREATION_FLAG_SHADER_DEVICE_ADDRESS;
			desc.mDesc.mSize = sizeof(GPUMaterial) * k_MaxMaterials;
			desc.mDesc.mElementCount = (uint32_t)(desc.mDesc.mSize / sizeof(uint32_t));
			desc.mDesc.bBindless = true;
			desc.pData = appState->materials;
			desc.mDesc.pName = "Materials Buffer";
			for (uint32_t i = 0; i < kDataBufferCount; ++i)
			{
				desc.ppBuffer = &appState->materialBuffers[i];
				::addResource(&desc, NULL);
			}
		}

		// Instances
		{
			appState->instances = (GPUInstance*)tf_malloc(sizeof(GPUInstance) * k_MaxInstances);
			assert(appState->instances);
			memset(appState->instances, 0, sizeof(GPUInstance) * k_MaxInstances);

			appState->maxIndirectDrawIndexArgs = k_MaxIndirectDrawIndexArgs;

			for (uint32_t i = 0; i < kDataBufferCount; ++i)
			{
				appState->indirectDrawIndexArgs[i] = (::IndirectDrawIndexArguments*)tf_malloc(sizeof(::IndirectDrawIndexArguments) * appState->maxIndirectDrawIndexArgs);
				assert(appState->indirectDrawIndexArgs[i]);
				memset(appState->indirectDrawIndexArgs[i], 0, sizeof(::IndirectDrawIndexArguments) * appState->maxIndirectDrawIndexArgs);
				appState->numIndirectDrawIndexArgs[i] = 0;
			}

			// NOTE: The first entity is the player
			// Player Instance
			{
				uint32_t startInstance = appState->numInstances;
				assert(startInstance == 0);
				uint32_t meshIndex = (uint32_t)Meshes::Cube;
				GPUInstance& instance = appState->instances[appState->numInstances++];
				::mat4 translate = ::mat4::translation({ 0.0f, 0.0f, 1.0f });
				::mat4 scale = ::mat4::scale({ 0.25f, 0.25f, 1.0f });
				loadMat4(translate * scale, &instance.worldMat.m[0]);
				instance.meshIndex = meshIndex;
				instance.materialBufferIndex = 0;

				const GPUMesh& mesh = appState->meshes[meshIndex];
				for (uint32_t i = 0; i < kDataBufferCount; ++i)
				{
					::IndirectDrawIndexArguments* drawIndexArgs = &appState->indirectDrawIndexArgs[i][appState->numIndirectDrawIndexArgs[i]++];
					drawIndexArgs->mIndexCount = mesh.indexCount;
					drawIndexArgs->mStartIndex = mesh.indexOffset;
					drawIndexArgs->mVertexOffset = mesh.vertexOffset;
					drawIndexArgs->mInstanceCount = 1;
					drawIndexArgs->mStartInstance = startInstance;
				}
			}

			// TODO: Do not generate these here, but in the gameplay code (once we have it)
			// Plane Instances for the ground
			{
				uint32_t startInstance = appState->numInstances;
				uint32_t numInstances = 0;
				uint32_t meshIndex = (uint32_t)Meshes::Plane;
				for (int32_t y = -50; y < 50; y++)
				{
					for (int32_t x = -50; x < 50; x++)
					{
						GPUInstance& instance = appState->instances[appState->numInstances++];
						::mat4 translate = ::mat4::translation({ x + 0.5f, y + 0.5f, 0.0f });
						loadMat4(translate, &instance.worldMat.m[0]);
						instance.meshIndex = meshIndex;
						instance.materialBufferIndex = 1;
						numInstances++;
					}
				}

				const GPUMesh& mesh = appState->meshes[meshIndex];

				for (uint32_t i = 0; i < kDataBufferCount; ++i)
				{
					::IndirectDrawIndexArguments* drawIndexArgs = &appState->indirectDrawIndexArgs[i][appState->numIndirectDrawIndexArgs[i]++];
					drawIndexArgs->mIndexCount = mesh.indexCount;
					drawIndexArgs->mStartIndex = mesh.indexOffset;
					drawIndexArgs->mVertexOffset = mesh.vertexOffset;
					drawIndexArgs->mInstanceCount = numInstances;
					drawIndexArgs->mStartInstance = startInstance;
				}
			}

			//// Damaged Helmet Instance
			//{
			//	uint32_t startInstance = appState->numInstances;
			//	GPUInstance& instance = appState->instances[appState->numInstances++];
			//	::mat4 translate = ::mat4::translation({ 0.0f, 0.0f, 0.75f });
			//	loadMat4(translate, &instance.worldMat.m[0]);
			//	instance.meshIndex = (uint32_t)Meshes::DamagedHelmet;
			//	instance.materialBufferIndex = 1;

			//	const GPUMesh& mesh = appState->meshes[instance.meshIndex];

			//	for (uint32_t i = 0; i < kDataBufferCount; ++i)
			//	{
			//		::IndirectDrawIndexArguments* drawIndexArgs = &appState->indirectDrawIndexArgs[i][appState->numIndirectDrawIndexArgs[i]++];
			//		drawIndexArgs->mIndexCount = mesh.indexCount;
			//		drawIndexArgs->mStartIndex = mesh.indexOffset;
			//		drawIndexArgs->mVertexOffset = mesh.vertexOffset;
			//		drawIndexArgs->mInstanceCount = 2;
			//		drawIndexArgs->mStartInstance = startInstance;
			//	}
			//}

			::BufferLoadDesc desc = {};
			desc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_BUFFER_RAW;
			desc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_GPU_ONLY;
			desc.mDesc.mFlags = ::BUFFER_CREATION_FLAG_SHADER_DEVICE_ADDRESS;
			desc.mDesc.mSize = sizeof(GPUInstance) * k_MaxInstances;
			desc.mDesc.mElementCount = (uint32_t)(desc.mDesc.mSize / sizeof(uint32_t));
			desc.mDesc.bBindless = true;
			desc.pData = appState->instances;
			desc.mDesc.pName = "Instances Buffer";
			for (uint32_t i = 0; i < kDataBufferCount; ++i)
			{
				desc.ppBuffer = &appState->instanceBuffers[i];
				::addResource(&desc, NULL);
			}

			// Indirect draw args buffers
			{
				::BufferLoadDesc desc = {};
				desc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_INDIRECT_BUFFER;
				desc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_GPU_ONLY;
				desc.mDesc.mFlags = ::BUFFER_CREATION_FLAG_SHADER_DEVICE_ADDRESS;
				desc.mDesc.mSize = sizeof(::IndirectDrawIndexArguments) * appState->maxIndirectDrawIndexArgs;
				desc.mDesc.mElementCount = (uint32_t)(desc.mDesc.mSize / sizeof(uint32_t));
				desc.mDesc.bBindless = false;
				desc.mDesc.mStartState = ::RESOURCE_STATE_INDIRECT_ARGUMENT;
				desc.mDesc.pName = "Indirect Draw Buffer";

				for (uint32_t i = 0; i < kDataBufferCount; ++i)
				{
					desc.pData = appState->indirectDrawIndexArgs[i];
					desc.ppBuffer = &appState->indirectDrawBuffers[i];
					::addResource(&desc, NULL);
				}
			}
		}

		// Lights
		{
			appState->numLights = 3;
			appState->lights = (GPULight*)tf_malloc(sizeof(GPULight) * appState->numLights);
			assert(appState->lights);
			memset(appState->lights, 0, sizeof(GPULight)* appState->numLights);

			// Key light
			GPULight& keyLight = appState->lights[0];
			keyLight.position = { 4.0f, -4.0f, 5.5f };
			keyLight.range = 15.0f;
			keyLight.color = ::srgbToLinearf3({ 1.0f, 0.2f, 0.2f });
			keyLight.intensity = 10.0f;

			// Fill light
			GPULight& fillLight = appState->lights[1];
			fillLight.position = { -4.0f, -3.0f, 5.5f };
			fillLight.range = 15.0f;
			fillLight.color = ::srgbToLinearf3({ 0.2f, 0.2f, 1.0f });
			fillLight.intensity = 5.0f;

			// Back light
			GPULight& backLight = appState->lights[2];
			backLight.position = { 0.0f, 3.0f, 8.0f };
			backLight.range = 15.0f;
			backLight.color = ::srgbToLinearf3({ 0.2f, 1.0, 0.2f });
			backLight.intensity = 10.0f;
			
			::BufferLoadDesc desc = {};
			desc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_BUFFER_RAW;
			desc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_GPU_ONLY;
			desc.mDesc.mFlags = ::BUFFER_CREATION_FLAG_SHADER_DEVICE_ADDRESS;
			desc.mDesc.mSize = sizeof(GPUInstance) * appState->numLights;
			desc.mDesc.mElementCount = (uint32_t)(desc.mDesc.mSize / sizeof(uint32_t));
			desc.mDesc.bBindless = true;
			desc.pData = appState->lights;
			desc.mDesc.pName = "Lights Buffer";
			for (uint32_t i = 0; i < kDataBufferCount; ++i)
			{
				desc.ppBuffer = &appState->lightBuffers[i];
				::addResource(&desc, NULL);
			}
		}
	}

	if (!renderer_OnLoad(appState, { ::RELOAD_TYPE_ALL }))
	{
		SDL_Log("Couldn't load renderer resources");
		return false;
	}

	::waitForAllResourceLoads();

	return true;
}

void renderer_Exit(AppState* appState)
{
	if (!appState)
	{
		SDL_Log("AppState has not been initialized");
		return;
	}

	tf_free(appState->materials);
	tf_free(appState->instances);
	tf_free(appState->lights);

	renderer_OnUnload(appState, { ::RELOAD_TYPE_ALL });

	::exitRootSignature(appState->renderer);

	renderer_RemoveGeometry(appState);

	::removeResource(appState->gridAlbedoTexture);
	::removeResource(appState->gridOrmTexture);
	::removeResource(appState->damagedHelmetAlbedoTexture);
	::removeResource(appState->damagedHelmetNormalTexture);
	::removeResource(appState->damagedHelmetOrmTexture);
	::removeResource(appState->damagedHelmetEmissiveTexture);
	::removeResource(appState->tonyMcMapfaceLUT);

	::removeSampler(appState->renderer, appState->linearRepeatSampler);
	::removeSampler(appState->renderer, appState->linearClampSampler);

	for (uint32_t i = 0; i < kDataBufferCount; ++i)
	{
		::removeResource(appState->frameUniformBuffers[i]);
		::removeResource(appState->materialBuffers[i]);
		::removeResource(appState->instanceBuffers[i]);
		::removeResource(appState->lightBuffers[i]);
	}

	for (uint32_t i = 0; i < kDataBufferCount; ++i)
	{
		::removeResource(appState->indirectDrawBuffers[i]);
		tf_free(appState->indirectDrawIndexArgs[i]);
	}

	for (uint32_t i = 0; i < kDownsampleSteps; ++i)
	{
		::removeResource(appState->downsampleUniformBuffers[i]);
	}

	for (uint32_t i = 0; i < kUpsampleSteps; ++i)
	{
		::removeResource(appState->upsampleUniformBuffers[i]);
	}

	::exitGpuCmdRing(appState->renderer, &appState->graphicsCmdRing);
	::exitSemaphore(appState->renderer, appState->imageAcquiredSemaphore);
	::exitResourceLoaderInterface(appState->renderer);

	::exitQueue(appState->renderer, appState->graphicsQueue);

	::exitRenderer(appState->renderer);
	::exitGPUConfiguration();
	::exitLog();
	::exitFileSystem();
	::exitMemAlloc();
}

bool renderer_OnLoad(AppState* appState, ::ReloadDesc reloadDesc)
{
	assert(appState);
	assert(appState->renderer);

	if (reloadDesc.mType & ::RELOAD_TYPE_SHADER)
	{
		renderer_AddShaders(appState);
		renderer_AddDescriptorSets(appState);
	}

	if (reloadDesc.mType & (::RELOAD_TYPE_RESIZE | ::RELOAD_TYPE_RENDERTARGET))
	{
		if (!renderer_AddSwapChain(appState))
		{
			return false;
		}

		if (!renderer_AddRenderTargets(appState))
		{
			return false;
		}
	}

	if (reloadDesc.mType & (::RELOAD_TYPE_SHADER | ::RELOAD_TYPE_RENDERTARGET))
	{
		renderer_AddPipelines(appState);
	}

	renderer_PrepareDescriptorSets(appState);

	return true;
}

void renderer_OnUnload(AppState* appState, ReloadDesc reloadDesc)
{
	assert(appState);
	assert(appState->renderer);

	::waitQueueIdle(appState->graphicsQueue);

	if (reloadDesc.mType & (::RELOAD_TYPE_SHADER | ::RELOAD_TYPE_RENDERTARGET))
	{
		renderer_RemovePipelines(appState);
	}

	if (reloadDesc.mType & (::RELOAD_TYPE_RESIZE | ::RELOAD_TYPE_RENDERTARGET))
	{
		renderer_RemoveSwapChain(appState);
		renderer_RemoveRenderTargets(appState);
	}

	if (reloadDesc.mType & ::RELOAD_TYPE_SHADER)
	{
		renderer_RemoveDescriptorSets(appState);
		renderer_RemoveShaders(appState);
	}
}

bool renderer_AddSwapChain(AppState* appState)
{
	SDL_PropertiesID properties = SDL_GetWindowProperties(appState->window);
	void* hwnd = SDL_GetPointerProperty(properties, SDL_PROP_WINDOW_WIN32_HWND_POINTER, NULL);
	::WindowHandle windowHandle = { ::WINDOW_HANDLE_TYPE_WIN32, (HWND)hwnd };

	int32_t width;
	int32_t height;
	SDL_GetWindowSizeInPixels(appState->window, &width, &height);

	::SwapChainDesc desc = {};
	desc.mWindowHandle = windowHandle;
	desc.mPresentQueueCount = 1;
	desc.ppPresentQueues = &appState->graphicsQueue;
	desc.mWidth = (uint32_t)width;
	desc.mHeight = (uint32_t)height;
	desc.mImageCount = ::getRecommendedSwapchainImageCount(appState->renderer, &windowHandle);
	desc.mColorFormat = ::getSupportedSwapchainFormat(appState->renderer, &desc, ::COLOR_SPACE_SDR_SRGB);
	desc.mColorSpace = ::COLOR_SPACE_SDR_SRGB;
	desc.mEnableVsync = true;
	desc.mFlags = ::SWAP_CHAIN_CREATION_FLAG_NONE;
	::addSwapChain(appState->renderer, &desc, &appState->swapChain);

	return appState->swapChain != NULL;
}

void renderer_RemoveSwapChain(AppState* appState)
{
	::removeSwapChain(appState->renderer, appState->swapChain);
}

bool renderer_AddRenderTargets(AppState* appState)
{
	int32_t windowWidth;
	int32_t windowHeight;
	SDL_GetWindowSizeInPixels(appState->window, &windowWidth, &windowHeight);

	// Add Depth Buffer
	{
		::RenderTargetDesc desc = {};
		desc.mWidth = (uint32_t)windowWidth;
		desc.mHeight = (uint32_t)windowHeight;
		desc.mDepth = 1;
		desc.mArraySize = 1;
		desc.mClearValue.depth = 0.0f;
		desc.mClearValue.stencil = 0;
		desc.mFormat = ::TinyImageFormat_D32_SFLOAT;
		desc.mStartState = ::RESOURCE_STATE_DEPTH_WRITE;
		desc.mSampleCount = ::SAMPLE_COUNT_1;
		desc.mSampleQuality = 0;
		desc.mFlags = ::TEXTURE_CREATION_FLAG_ON_TILE;
		::addRenderTarget(appState->renderer, &desc, &appState->depthBuffer);

		if (!appState->depthBuffer)
		{
			LOGF(eERROR, "Failed to create depth buffer");
			return false;
		}
	}

	// Add Scene Color
	{
		::RenderTargetDesc desc = {};
		desc.mWidth = (uint32_t)windowWidth;
		desc.mHeight = (uint32_t)windowHeight;
		desc.mDepth = 1;
		desc.mArraySize = 1;
		desc.mClearValue = { 0.0f, 0.0f, 0.0f, 0.0f };
		desc.mFormat = ::TinyImageFormat_R16G16B16A16_SFLOAT;
		desc.mStartState = ::RESOURCE_STATE_SHADER_RESOURCE;
		desc.mSampleCount = ::SAMPLE_COUNT_1;
		desc.mSampleQuality = 0;
		desc.mFlags = ::TEXTURE_CREATION_FLAG_ON_TILE;
		::addRenderTarget(appState->renderer, &desc, &appState->sceneColor);

		if (!appState->sceneColor)
		{
			LOGF(eERROR, "Failed to create the scene color buffer");
			return false;
		}
	}

	// Add downsample textures
	{
		::TextureDesc desc = {};
		desc.mDepth = 1;
		desc.mArraySize = 1;
		desc.mMipLevels = 1;
		desc.mFormat = ::TinyImageFormat_R16G16B16A16_SFLOAT;
		desc.mStartState = ::RESOURCE_STATE_SHADER_RESOURCE;
		desc.mDescriptors = ::DESCRIPTOR_TYPE_TEXTURE | ::DESCRIPTOR_TYPE_RW_TEXTURE;
		desc.mSampleCount = ::SAMPLE_COUNT_1;
		desc.mSampleQuality = 0;
		desc.bBindless = false;
		::TextureLoadDesc loadDesc = {};
		loadDesc.pDesc = &desc;

		::SyncToken texturesToken = NULL;
		for (uint32_t i = 0; i < kDownsampleSteps; i++)
		{
			desc.mWidth = (uint32_t)windowWidth >> (i + 1);
			desc.mHeight = (uint32_t)windowHeight >> (i + 1);
			loadDesc.ppTexture = &appState->bloomDownsamples[i];
			::addResource(&loadDesc, &texturesToken);
		}

		::waitForToken(&texturesToken);
	}

	// Add upsample textures
	{
		::TextureDesc desc = {};
		desc.mDepth = 1;
		desc.mArraySize = 1;
		desc.mMipLevels = 1;
		desc.mFormat = ::TinyImageFormat_R16G16B16A16_SFLOAT;
		desc.mStartState = ::RESOURCE_STATE_SHADER_RESOURCE;
		desc.mDescriptors = ::DESCRIPTOR_TYPE_TEXTURE | ::DESCRIPTOR_TYPE_RW_TEXTURE;
		desc.mSampleCount = ::SAMPLE_COUNT_1;
		desc.mSampleQuality = 0;
		desc.bBindless = false;
		::TextureLoadDesc loadDesc = {};
		loadDesc.pDesc = &desc;

		::SyncToken texturesToken = NULL;
		for (uint32_t i = 0; i < kUpsampleSteps; ++i)
		{
			desc.mWidth = (uint32_t)windowWidth >> (kUpsampleSteps - i);
			desc.mHeight = (uint32_t)windowHeight >> (kUpsampleSteps - i);
			loadDesc.ppTexture = &appState->bloomUpsamples[i];
			::addResource(&loadDesc, &texturesToken);
		}

		::waitForToken(&texturesToken);
	}

	return true;
}

void renderer_RemoveRenderTargets(AppState* appState)
{
	::removeRenderTarget(appState->renderer, appState->depthBuffer);
	::removeRenderTarget(appState->renderer, appState->sceneColor);

	for (uint32_t i = 0; i < kDownsampleSteps; i++)
	{
		::removeResource(appState->bloomDownsamples[i]);
	}

	for (uint32_t i = 0; i < kUpsampleSteps; i++)
	{
		::removeResource(appState->bloomUpsamples[i]);
	}
}

void renderer_Draw(AppState* appState)
{
	int32_t windowWidth;
	int32_t windowHeight;
	SDL_GetWindowSizeInPixels(appState->window, &windowWidth, &windowHeight);

	uint32_t swapChainImageIndex;
	::acquireNextImage(appState->renderer, appState->swapChain, appState->imageAcquiredSemaphore, NULL, &swapChainImageIndex);

	::RenderTarget* swapChainBuffer = appState->swapChain->ppRenderTargets[swapChainImageIndex];
	::GpuCmdRingElement elem = ::getNextGpuCmdRingElement(&appState->graphicsCmdRing, true, 1);

	// Stall if CPU is running 2 frames ahead of GPU
	::FenceStatus fenceStatus;
	::getFenceStatus(appState->renderer, elem.pFence, &fenceStatus);
	if (fenceStatus == ::FENCE_STATUS_INCOMPLETE)
		::waitForFences(appState->renderer, 1, &elem.pFence);

	::resetCmdPool(appState->renderer, elem.pCmdPool);

	::Cmd* cmd = elem.pCmds[0];
	::beginCmd(cmd);

	// Forward Pass
	{
		// Resource Barriers
		{
			::RenderTargetBarrier rtBarriers[] = {
				{ appState->sceneColor, ::RESOURCE_STATE_SHADER_RESOURCE, ::RESOURCE_STATE_RENDER_TARGET },
			};
			::cmdResourceBarrier(cmd, 0, NULL, 0, NULL, TF_ARRAY_COUNT(rtBarriers), rtBarriers);
		}

		// Binding Render Targets
		{
			BindRenderTargetsDesc bindRenderTargets = {};
			bindRenderTargets.mRenderTargetCount = 1;
			bindRenderTargets.mRenderTargets[0] = {};
			bindRenderTargets.mRenderTargets[0].pRenderTarget = appState->sceneColor;
			bindRenderTargets.mRenderTargets[0].mLoadAction = ::LOAD_ACTION_CLEAR;
			bindRenderTargets.mDepthStencil.mLoadAction = ::LOAD_ACTION_CLEAR;
			bindRenderTargets.mDepthStencil.pDepthStencil = appState->depthBuffer;
			::cmdBindRenderTargets(cmd, &bindRenderTargets);
		}

		::cmdSetViewport(cmd, 0.0f, 0.0f, (float)windowWidth, (float)windowHeight, 0.0f, 1.0f);
		::cmdSetScissor(cmd, 0, 0, (uint32_t)windowWidth, (uint32_t)windowHeight);

		// Update Transforms
		// NOTE(gmodarelli): We should split the instance buffer in dynamic and static.
		// For now we're just updating the player transform, since it's the only dynamic instance
		{
			uint32_t playerInstanceIndex = 0;
			uint32_t meshIndex = (uint32_t)Meshes::Cube;
			GPUInstance& instance = appState->instances[playerInstanceIndex];
			::mat4 translate = ::mat4::translation({
				appState->gameState.playerPosition.x,
				appState->gameState.playerPosition.y,
				appState->gameState.playerPosition.z,
			}); 
			::mat4 scale = ::mat4::scale({ 0.25f, 0.25f, 1.0f });
			loadMat4(translate* scale, &instance.worldMat.m[0]);
			instance.meshIndex = meshIndex;
			instance.materialBufferIndex = 0;

			::BufferUpdateDesc updateDesc = {};
			updateDesc.pBuffer = appState->instanceBuffers[appState->frameIndex];
			updateDesc.mDstOffset = 0; // The player instance is at the start of the instance buffer
			updateDesc.mSize = sizeof(GPUInstance);
			::beginUpdateResource(&updateDesc);
			memcpy(updateDesc.pMappedData, &instance, sizeof(GPUInstance));
			::endUpdateResource(&updateDesc);
		}

		// Render meshes
		{
			::mat4 projMat = ::mat4::perspectiveRH(1.0471f, windowHeight / (float)windowWidth, 100.0f, 0.01f);
			::mat4 projViewMat = projMat * appState->playerCamera.viewMatrix;
			Frame frameData = {};
			loadMat4(projViewMat, &frameData.projViewMat.m[0]);
			frameData.sunColor = { appState->sunColor.x, appState->sunColor.y, appState->sunColor.z, appState->sunIntensity };
			frameData.sunDirection = { appState->sunDirection.x, appState->sunDirection.y, appState->sunDirection.z, 0.0f };
			frameData.meshBufferIndex = (uint32_t)appState->meshesBuffer->mDx.mDescriptors;
			frameData.vertexBufferIndex = (uint32_t)appState->vertexBuffer->mDx.mDescriptors;
			frameData.materialBufferIndex = (uint32_t)appState->materialBuffers[appState->frameIndex]->mDx.mDescriptors;
			frameData.instanceBufferIndex = (uint32_t)appState->instanceBuffers[appState->frameIndex]->mDx.mDescriptors;
			frameData.lightBufferIndex = (uint32_t)appState->lightBuffers[appState->frameIndex]->mDx.mDescriptors;
			frameData.numLights = appState->numLights;

			::BufferUpdateDesc desc = { appState->frameUniformBuffers[appState->frameIndex] };
			::beginUpdateResource(&desc);
			memcpy(desc.pMappedData, &frameData, sizeof(frameData));
			::endUpdateResource(&desc);

			::cmdBindPipeline(cmd, appState->uberPipeline);
			::cmdBindDescriptorSet(cmd, 0, appState->uberPersistentDescriptorSet);
			::cmdBindDescriptorSet(cmd, appState->frameIndex, appState->uberPerFrameDescriptorSet);
			::cmdBindIndexBuffer(cmd, appState->indexBuffer, ::INDEX_TYPE_UINT32, 0);

			::cmdExecuteIndirect(cmd, ::INDIRECT_DRAW_INDEX, 2, appState->indirectDrawBuffers[appState->frameIndex], 0, NULL, 0);
		}

		::cmdBindRenderTargets(cmd, NULL);
	}

	// Bloom
	{
		// Downsample
		for (uint32_t i = 0; i < kDownsampleSteps; ++i)
		{
			// NOTE(gmodarelli): This could be a simple push constant
			DownsampleUniform uniform = {};
			if (i == 0)
			{
				uniform.inputSize = { appState->sceneColor->mWidth, appState->sceneColor->mHeight };

				// Resource Barriers
				{
					::RenderTargetBarrier rtBarriers[] = {
						{ appState->sceneColor, ::RESOURCE_STATE_RENDER_TARGET, ::RESOURCE_STATE_SHADER_RESOURCE }
					};
					::TextureBarrier tBarriers[] = {
						{ appState->bloomDownsamples[i], ::RESOURCE_STATE_SHADER_RESOURCE, ::RESOURCE_STATE_UNORDERED_ACCESS }
					};
					::cmdResourceBarrier(cmd, 0, NULL, TF_ARRAY_COUNT(tBarriers), tBarriers, TF_ARRAY_COUNT(rtBarriers), rtBarriers);
				}
			}
			else
			{
				uniform.inputSize = { appState->bloomDownsamples[i - 1]->mWidth, appState->bloomDownsamples[i - 1]->mHeight };

				// Resource Barriers
				{
					::TextureBarrier tBarriers[] = {
						{ appState->bloomDownsamples[i - 1], ::RESOURCE_STATE_UNORDERED_ACCESS, ::RESOURCE_STATE_SHADER_RESOURCE },
						{ appState->bloomDownsamples[i], ::RESOURCE_STATE_SHADER_RESOURCE, ::RESOURCE_STATE_UNORDERED_ACCESS }
					};
					::cmdResourceBarrier(cmd, 0, NULL, TF_ARRAY_COUNT(tBarriers), tBarriers, 0, NULL);
				}
			}

			::BufferUpdateDesc desc = { appState->downsampleUniformBuffers[i] };
			::beginUpdateResource(&desc);
			memcpy(desc.pMappedData, &uniform, sizeof(uniform));
			::endUpdateResource(&desc);

			::cmdBindPipeline(cmd, appState->downsamplePipeline);
			::cmdBindDescriptorSet(cmd, 0, appState->downsamplePersistentDescriptorSet);
			::cmdBindDescriptorSet(cmd, i, appState->downsamplePerDrawDescriptorSet);
			::cmdDispatch(cmd, (appState->bloomDownsamples[i]->mWidth / 8) + 1, (appState->bloomDownsamples[i]->mHeight / 8) + 1, 1);
		}

		// Upsample
		for (uint32_t i = 0; i < kUpsampleSteps; ++i)
		{
			UpsampleUniform uniform = {};
			uniform.radius = 0.75f;

			if (i == 0)
			{
				uniform.inputSize = { appState->bloomDownsamples[kDownsampleSteps - 1]->mWidth, appState->bloomDownsamples[kDownsampleSteps - 1]->mHeight };

				// Resource Barriers
				{
					::TextureBarrier tBarriers[] = {
						{ appState->bloomDownsamples[kDownsampleSteps - 1], ::RESOURCE_STATE_UNORDERED_ACCESS, ::RESOURCE_STATE_SHADER_RESOURCE },
						{ appState->bloomUpsamples[i], ::RESOURCE_STATE_SHADER_RESOURCE, ::RESOURCE_STATE_UNORDERED_ACCESS }
					};
					::cmdResourceBarrier(cmd, 0, NULL, TF_ARRAY_COUNT(tBarriers), tBarriers, 0, NULL);
				}
			}
			else
			{
				uniform.inputSize = { appState->bloomUpsamples[i - 1]->mWidth, appState->bloomUpsamples[i - 1]->mHeight };

				// Resource Barriers
				{
					::TextureBarrier tBarriers[] = {
						{ appState->bloomUpsamples[i - 1], ::RESOURCE_STATE_UNORDERED_ACCESS, ::RESOURCE_STATE_SHADER_RESOURCE },
						{ appState->bloomUpsamples[i], ::RESOURCE_STATE_SHADER_RESOURCE, ::RESOURCE_STATE_UNORDERED_ACCESS }
					};
					::cmdResourceBarrier(cmd, 0, NULL, TF_ARRAY_COUNT(tBarriers), tBarriers, 0, NULL);
				}
			}

			::BufferUpdateDesc desc = { appState->upsampleUniformBuffers[i] };
			::beginUpdateResource(&desc);
			memcpy(desc.pMappedData, &uniform, sizeof(uniform));
			::endUpdateResource(&desc);

			::cmdBindPipeline(cmd, appState->upsamplePipeline);
			::cmdBindDescriptorSet(cmd, 0, appState->upsamplePersistentDescriptorSet);
			::cmdBindDescriptorSet(cmd, i, appState->upsamplePerDrawDescriptorSet);
			::cmdDispatch(cmd, (appState->bloomUpsamples[i]->mWidth / 8) + 1, (appState->bloomUpsamples[i]->mHeight / 8) + 1, 1);
		}

		// Resource Barriers
		{
			::TextureBarrier tBarriers[] = {
				{ appState->bloomUpsamples[kUpsampleSteps - 1], ::RESOURCE_STATE_UNORDERED_ACCESS, ::RESOURCE_STATE_SHADER_RESOURCE }
			};
			::cmdResourceBarrier(cmd, 0, NULL, TF_ARRAY_COUNT(tBarriers), tBarriers, 0, NULL);
		}
	}

	// Tone Mapping Pass
	{
		// Resource Barriers
		{
			::RenderTargetBarrier rtBarriers[] = {
				{ swapChainBuffer, ::RESOURCE_STATE_PRESENT, ::RESOURCE_STATE_RENDER_TARGET },
			};
			::cmdResourceBarrier(cmd, 0, NULL, 0, NULL, TF_ARRAY_COUNT(rtBarriers), rtBarriers);
		}

		// Binding Render Targets
		{
			BindRenderTargetsDesc bindRenderTargets = {};
			bindRenderTargets.mRenderTargetCount = 1;
			bindRenderTargets.mRenderTargets[0] = {};
			bindRenderTargets.mRenderTargets[0].pRenderTarget = swapChainBuffer;
			bindRenderTargets.mRenderTargets[0].mLoadAction = ::LOAD_ACTION_CLEAR;
			::cmdBindRenderTargets(cmd, &bindRenderTargets);
		}

		::cmdSetViewport(cmd, 0.0f, 0.0f, (float)windowWidth, (float)windowHeight, 0.0f, 1.0f);
		::cmdSetScissor(cmd, 0, 0, (uint32_t)windowWidth, (uint32_t)windowHeight);

		::cmdBindPipeline(cmd, appState->toneMappingPipeline);
		::cmdBindDescriptorSet(cmd, 0, appState->toneMappingPersistentDescriptorSet);
		::cmdBindDescriptorSet(cmd, appState->frameIndex, appState->toneMappingPerFrameDescriptorSet);
		::cmdDraw(cmd, 3, 0);

		// Resource Barriers
		{
			::RenderTargetBarrier rtBarriers[] = {
				{ swapChainBuffer, ::RESOURCE_STATE_RENDER_TARGET, ::RESOURCE_STATE_PRESENT },
			};
			::cmdResourceBarrier(cmd, 0, NULL, 0, NULL, TF_ARRAY_COUNT(rtBarriers), rtBarriers);
		}

		::cmdBindRenderTargets(cmd, NULL);
	}

	::endCmd(cmd);

	::FlushResourceUpdateDesc flushUpdateDesc = {};
	flushUpdateDesc.mNodeIndex = 0;
	::flushResourceUpdates(&flushUpdateDesc);
	::Semaphore* waitSemaphores[2] = { flushUpdateDesc.pOutSubmittedSemaphore, appState->imageAcquiredSemaphore };

	::QueueSubmitDesc submitDesc = {};
	submitDesc.mCmdCount = 1;
	submitDesc.mSignalSemaphoreCount = 1;
	submitDesc.mWaitSemaphoreCount = TF_ARRAY_COUNT(waitSemaphores);
	submitDesc.ppCmds = &cmd;
	submitDesc.ppSignalSemaphores = &elem.pSemaphore;
	submitDesc.ppWaitSemaphores = waitSemaphores;
	submitDesc.pSignalFence = elem.pFence;
	::queueSubmit(appState->graphicsQueue, &submitDesc);

	::QueuePresentDesc presentDesc = {};
	presentDesc.mIndex = (uint8_t)swapChainImageIndex;
	presentDesc.mWaitSemaphoreCount = 1;
	presentDesc.pSwapChain = appState->swapChain;
	presentDesc.ppWaitSemaphores = &elem.pSemaphore;
	presentDesc.mSubmitDone = true;

	::queuePresent(appState->graphicsQueue, &presentDesc);

	appState->frameIndex = (appState->frameIndex + 1) % kDataBufferCount;
}


void renderer_AddShaders(AppState* appState)
{
	// Uber Shader
	{
		ShaderLoadDesc uberShader = {};
		uberShader.mVert.pFileName = "Uber.vert";
		uberShader.mFrag.pFileName = "Uber.pixel";
		::addShader(appState->renderer, &uberShader, &appState->uberShader);
	}

	// Downsample Shader
	{
		ShaderLoadDesc downsampleShader = {};
		downsampleShader.mComp.pFileName = "Downsample.comp";
		::addShader(appState->renderer, &downsampleShader, &appState->downsampleShader);
	}

	// Upsample Shader
	{
		ShaderLoadDesc upsampleShader = {};
		upsampleShader.mComp.pFileName = "Upsample.comp";
		::addShader(appState->renderer, &upsampleShader, &appState->upsampleShader);
	}

	// Tone mapping
	{
		ShaderLoadDesc uberShader = {};
		uberShader.mVert.pFileName = "FullscreenTriangle.vert";
		uberShader.mFrag.pFileName = "Tonemap.pixel";
		::addShader(appState->renderer, &uberShader, &appState->toneMapping);
	}
}

void renderer_RemoveShaders(AppState* appState)
{
	::removeShader(appState->renderer, appState->uberShader);
	::removeShader(appState->renderer, appState->downsampleShader);
	::removeShader(appState->renderer, appState->upsampleShader);
	::removeShader(appState->renderer, appState->toneMapping);
}

void renderer_AddDescriptorSets(AppState* appState)
{
	// Uber Shader Descriptor Sets
	{
		::DescriptorSetDesc desc = {};
		desc.mIndex = ROOT_PARAM_Persistent_SAMPLER;
		desc.mMaxSets = 1;
		desc.mNodeIndex = 0;
		desc.mDescriptorCount = 1;
		desc.pDescriptors = SRT_UberShaderData::PersistentPtr();
		::addDescriptorSet(appState->renderer, &desc, &appState->uberPersistentDescriptorSet);
	}

	{
		::DescriptorSetDesc desc = {};
		desc.mIndex = ROOT_PARAM_PerFrame;
		desc.mMaxSets = kDataBufferCount;
		desc.mNodeIndex = 0;
		desc.mDescriptorCount = 1;
		desc.pDescriptors = SRT_UberShaderData::PerFramePtr();
		::addDescriptorSet(appState->renderer, &desc, &appState->uberPerFrameDescriptorSet);
	}

	// Downsample Descriptor Sets
	{
		::DescriptorSetDesc desc = {};
		desc.mIndex = ROOT_PARAM_Persistent_SAMPLER;
		desc.mMaxSets = 1;
		desc.mNodeIndex = 0;
		desc.mDescriptorCount = 1;
		desc.pDescriptors = SRT_DownsampleData::PersistentPtr();
		::addDescriptorSet(appState->renderer, &desc, &appState->downsamplePersistentDescriptorSet);
	}

	{
		::DescriptorSetDesc desc = {};
		desc.mIndex = ROOT_PARAM_PerDraw;
		desc.mMaxSets = kDownsampleSteps;
		desc.mNodeIndex = 0;
		desc.mDescriptorCount = 3;
		desc.pDescriptors = SRT_DownsampleData::PerDrawPtr();
		::addDescriptorSet(appState->renderer, &desc, &appState->downsamplePerDrawDescriptorSet);
	}

	// Upsample Descriptor Sets
	{
		::DescriptorSetDesc desc = {};
		desc.mIndex = ROOT_PARAM_Persistent_SAMPLER;
		desc.mMaxSets = 1;
		desc.mNodeIndex = 0;
		desc.mDescriptorCount = 1;
		desc.pDescriptors = SRT_UpsampleData::PersistentPtr();
		::addDescriptorSet(appState->renderer, &desc, &appState->upsamplePersistentDescriptorSet);
	}

	{
		::DescriptorSetDesc desc = {};
		desc.mIndex = ROOT_PARAM_PerDraw;
		desc.mMaxSets = kUpsampleSteps;
		desc.mNodeIndex = 0;
		desc.mDescriptorCount = 4;
		desc.pDescriptors = SRT_UpsampleData::PerDrawPtr();
		::addDescriptorSet(appState->renderer, &desc, &appState->upsamplePerDrawDescriptorSet);
	}

	// Tone Mapping Descriptor Sets
	{
		::DescriptorSetDesc desc = {};
		desc.mIndex = ROOT_PARAM_Persistent_SAMPLER;
		desc.mMaxSets = 1;
		desc.mNodeIndex = 0;
		desc.mDescriptorCount = 1;
		desc.pDescriptors = SRT_ToneMappingData::PersistentPtr();
		::addDescriptorSet(appState->renderer, &desc, &appState->toneMappingPersistentDescriptorSet);
	}

	{
		::DescriptorSetDesc desc = {};
		desc.mIndex = ROOT_PARAM_PerFrame;
		desc.mMaxSets = kDataBufferCount;
		desc.mNodeIndex = 0;
		desc.mDescriptorCount = 3;
		desc.pDescriptors = SRT_ToneMappingData::PerFramePtr();
		::addDescriptorSet(appState->renderer, &desc, &appState->toneMappingPerFrameDescriptorSet);
	}
}

void renderer_PrepareDescriptorSets(AppState* appState)
{
	// Uber Shader Descriptor Sets
	{
		DescriptorData uParams[1] = {};
		uParams[0].mIndex = (offsetof(SRT_UberShaderData::Persistent, gLinearRepeatSampler)) / sizeof(::Descriptor);
		uParams[0].ppSamplers = &appState->linearRepeatSampler;
		updateDescriptorSet(appState->renderer, 0, appState->uberPersistentDescriptorSet, 1, uParams);
	}

	for (uint32_t i = 0; i < kDataBufferCount; ++i)
	{
		DescriptorData uParams[1] = {};
		uParams[0].mIndex = (offsetof(SRT_UberShaderData::PerFrame, CB0)) / sizeof(::Descriptor);
		uParams[0].ppBuffers = &appState->frameUniformBuffers[i];
		updateDescriptorSet(appState->renderer, i, appState->uberPerFrameDescriptorSet, 1, uParams);
	}

	// Downsample Descriptor Sets
	{
		DescriptorData uParams[1] = {};
		uParams[0].mIndex = (offsetof(SRT_DownsampleData::Persistent, gLinearClampSampler)) / sizeof(::Descriptor);
		uParams[0].ppSamplers = &appState->linearClampSampler;
		updateDescriptorSet(appState->renderer, 0, appState->downsamplePersistentDescriptorSet, 1, uParams);
	}

	for (uint32_t i = 0; i < kDownsampleSteps; ++i)
	{
		DescriptorData uParams[3] = {};
		uParams[0].mIndex = (offsetof(SRT_DownsampleData::PerDraw, CB0)) / sizeof(::Descriptor);
		uParams[0].ppBuffers = &appState->downsampleUniformBuffers[i];
		uParams[1].mIndex = (offsetof(SRT_DownsampleData::PerDraw, gSourceTexture)) / sizeof(::Descriptor);
		if (i == 0) {
			uParams[1].ppTextures = &appState->sceneColor->pTexture;
		} else {
			uParams[1].ppTextures = &appState->bloomDownsamples[i - 1];
		}
		uParams[2].mIndex = (offsetof(SRT_DownsampleData::PerDraw, gDestinationTexture)) / sizeof(::Descriptor);
		uParams[2].ppTextures = &appState->bloomDownsamples[i];
		updateDescriptorSet(appState->renderer, i, appState->downsamplePerDrawDescriptorSet, 3, uParams);
	}

	// Upsample Descriptor Sets
	{
		DescriptorData uParams[1] = {};
		uParams[0].mIndex = (offsetof(SRT_UpsampleData::Persistent, gLinearClampSampler)) / sizeof(::Descriptor);
		uParams[0].ppSamplers = &appState->linearClampSampler;
		updateDescriptorSet(appState->renderer, 0, appState->upsamplePersistentDescriptorSet, 1, uParams);
	}

	for (uint32_t i = 0; i < kUpsampleSteps; ++i)
	{
		DescriptorData uParams[4] = {};
		uParams[0].mIndex = (offsetof(SRT_UpsampleData::PerDraw, CB0)) / sizeof(::Descriptor);
		uParams[0].ppBuffers = &appState->upsampleUniformBuffers[i];
		uParams[1].mIndex = (offsetof(SRT_UpsampleData::PerDraw, gSourceTexture)) / sizeof(::Descriptor);
		uParams[1].ppTextures = &appState->bloomDownsamples[kUpsampleSteps - (i + 1)];
		uParams[2].mIndex = (offsetof(SRT_UpsampleData::PerDraw, gPreviousTexture)) / sizeof(::Descriptor);
		if (i == 0)
		{
			uParams[2].ppTextures = &appState->bloomDownsamples[kDownsampleSteps - 1];
		}
		else
		{
			uParams[2].ppTextures = &appState->bloomUpsamples[i - 1];
		}
		uParams[3].mIndex = (offsetof(SRT_UpsampleData::PerDraw, gDestinationTexture)) / sizeof(::Descriptor);
		uParams[3].ppTextures = &appState->bloomUpsamples[i];
		updateDescriptorSet(appState->renderer, i, appState->upsamplePerDrawDescriptorSet, 4, uParams);
	}

	// Tone Mapping Descriptor Sets
	{
		DescriptorData uParams[1] = {};
		uParams[0].mIndex = (offsetof(SRT_ToneMappingData::Persistent, gLinearClampSampler)) / sizeof(::Descriptor);
		uParams[0].ppSamplers = &appState->linearClampSampler;
		updateDescriptorSet(appState->renderer, 0, appState->toneMappingPersistentDescriptorSet, 1, uParams);
	}

	for (uint32_t i = 0; i < kDataBufferCount; ++i)
	{
		DescriptorData uParams[3] = {};
		uParams[0].mIndex = (offsetof(SRT_ToneMappingData::PerFrame, gSceneColor)) / sizeof(::Descriptor);
		uParams[0].ppTextures = &appState->sceneColor->pTexture;
		uParams[1].mIndex = (offsetof(SRT_ToneMappingData::PerFrame, gTonyMcMapfaceLut)) / sizeof(::Descriptor);
		uParams[1].ppTextures = &appState->tonyMcMapfaceLUT;
		uParams[2].mIndex = (offsetof(SRT_ToneMappingData::PerFrame, gBloomBuffer)) / sizeof(::Descriptor);
		uParams[2].ppTextures = &appState->bloomUpsamples[kUpsampleSteps - 1];
		updateDescriptorSet(appState->renderer, i, appState->toneMappingPerFrameDescriptorSet, 3, uParams);
	}
}

void renderer_RemoveDescriptorSets(AppState* appState)
{
	::removeDescriptorSet(appState->renderer, appState->uberPersistentDescriptorSet);
	::removeDescriptorSet(appState->renderer, appState->uberPerFrameDescriptorSet);
	::removeDescriptorSet(appState->renderer, appState->downsamplePersistentDescriptorSet);
	::removeDescriptorSet(appState->renderer, appState->downsamplePerDrawDescriptorSet);
	::removeDescriptorSet(appState->renderer, appState->upsamplePersistentDescriptorSet);
	::removeDescriptorSet(appState->renderer, appState->upsamplePerDrawDescriptorSet);
	::removeDescriptorSet(appState->renderer, appState->toneMappingPersistentDescriptorSet);
	::removeDescriptorSet(appState->renderer, appState->toneMappingPerFrameDescriptorSet);
}

void renderer_AddPipelines(AppState* appState)
{
	// Uber Shader Pipeline
	{
		::RasterizerStateDesc rasterizerStateDesc = {};
		rasterizerStateDesc.mCullMode = ::CULL_MODE_BACK;
		rasterizerStateDesc.mFrontFace = ::FRONT_FACE_CCW;

		::DepthStateDesc depthStateDesc = {};
		depthStateDesc.mDepthTest = true;
		depthStateDesc.mDepthWrite = true;
		depthStateDesc.mDepthFunc = ::CMP_GEQUAL;

		::TinyImageFormat colorFormats = { ::TinyImageFormat_R16G16B16A16_SFLOAT };

		::PipelineDesc desc = {};
		desc.mType = ::PIPELINE_TYPE_GRAPHICS;
		::GraphicsPipelineDesc& pipelineSettings = desc.mGraphicsDesc;
		pipelineSettings.mPrimitiveTopo = ::PRIMITIVE_TOPO_TRI_LIST;
		pipelineSettings.mRenderTargetCount = 1;
		pipelineSettings.pDepthState = &depthStateDesc;
		pipelineSettings.pColorFormats = &colorFormats;
		pipelineSettings.mSampleCount = ::SAMPLE_COUNT_1;
		pipelineSettings.mSampleQuality = 0;
		pipelineSettings.mDepthStencilFormat = appState->depthBuffer->mFormat;
		pipelineSettings.pShaderProgram = appState->uberShader;
		pipelineSettings.pVertexLayout = NULL;
		pipelineSettings.pRasterizerState = &rasterizerStateDesc;
		pipelineSettings.mVRFoveatedRendering = false;
		::addPipeline(appState->renderer, &desc, &appState->uberPipeline);
	}

	// Downsample Pipeline
	{
		::PipelineDesc desc = {};
		desc.mType = ::PIPELINE_TYPE_COMPUTE;

		::ComputePipelineDesc& pipelineSettings = desc.mComputeDesc;
		pipelineSettings.pShaderProgram = appState->downsampleShader;
		::addPipeline(appState->renderer, &desc, &appState->downsamplePipeline);
	}

	// Upsample Pipeline
	{
		::PipelineDesc desc = {};
		desc.mType = ::PIPELINE_TYPE_COMPUTE;

		::ComputePipelineDesc& pipelineSettings = desc.mComputeDesc;
		pipelineSettings.pShaderProgram = appState->upsampleShader;
		::addPipeline(appState->renderer, &desc, &appState->upsamplePipeline);
	}

	// Tone Mapping Pipeline
	{
		::RasterizerStateDesc rasterizerStateDesc = {};
		rasterizerStateDesc.mCullMode = ::CULL_MODE_NONE;

		::DepthStateDesc depthStateDesc = {};
		depthStateDesc.mDepthTest = false;
		depthStateDesc.mDepthWrite = false;

		::PipelineDesc desc = {};
		desc.mType = ::PIPELINE_TYPE_GRAPHICS;
		::GraphicsPipelineDesc& pipelineSettings = desc.mGraphicsDesc;
		pipelineSettings.mPrimitiveTopo = ::PRIMITIVE_TOPO_TRI_LIST;
		pipelineSettings.mRenderTargetCount = 1;
		pipelineSettings.pDepthState = &depthStateDesc;
		pipelineSettings.pColorFormats = &appState->swapChain->ppRenderTargets[0]->mFormat;
		pipelineSettings.mSampleCount = appState->swapChain->ppRenderTargets[0]->mSampleCount;
		pipelineSettings.mSampleQuality = appState->swapChain->ppRenderTargets[0]->mSampleQuality;
		pipelineSettings.mDepthStencilFormat = appState->depthBuffer->mFormat;
		pipelineSettings.pShaderProgram = appState->toneMapping;
		pipelineSettings.pVertexLayout = NULL;
		pipelineSettings.pRasterizerState = &rasterizerStateDesc;
		pipelineSettings.mVRFoveatedRendering = false;
		::addPipeline(appState->renderer, &desc, &appState->toneMappingPipeline);
	}
}

void renderer_RemovePipelines(AppState* appState)
{
	::removePipeline(appState->renderer, appState->uberPipeline);
	::removePipeline(appState->renderer, appState->downsamplePipeline);
	::removePipeline(appState->renderer, appState->upsamplePipeline);
	::removePipeline(appState->renderer, appState->toneMappingPipeline);
}

void renderer_AddGeometry(AppState* appState)
{
	const uint32_t maxVertices = 256 * 1024;
	const uint32_t maxIndices = 1024 * 1024;

	appState->geometry.vertices = (MeshVertex*)tf_malloc(sizeof(MeshVertex) * maxVertices);
	assert(appState->geometry.vertices);
	memset(appState->geometry.vertices, 0, sizeof(MeshVertex) * maxVertices);

	appState->geometry.indices = (uint32_t*)tf_malloc(sizeof(uint32_t) * maxIndices);
	assert(appState->geometry.indices);
	memset(appState->geometry.indices, 0, sizeof(uint32_t) * maxIndices);

	appState->meshes = (GPUMesh*)tf_malloc(sizeof(GPUMesh) * k_MaxMeshes);
	assert(appState->meshes);
	memset(appState->meshes, 0, sizeof(GPUMesh) * k_MaxMeshes);
	appState->numMeshes = 0;

	GPUMesh* plane = &appState->meshes[(size_t)Meshes::Plane];
	const char* planePath = "Content/Models/Plane.obj";
	renderer_LoadMesh(&appState->geometry, planePath, plane);

	GPUMesh* cube = &appState->meshes[(size_t)Meshes::Cube];
	const char* cubePath = "Content/Models/Cube.obj";
	renderer_LoadMesh(&appState->geometry, cubePath, cube);

	GPUMesh* helmet = &appState->meshes[(size_t)Meshes::DamagedHelmet];
	const char* helmetPath = "Content/Models/DamagedHelmet.obj";
	renderer_LoadMesh(&appState->geometry, helmetPath, helmet);

	appState->numMeshes = (uint32_t)Meshes::_Count;

	{
		::BufferLoadDesc meshDesc = {};
		meshDesc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_BUFFER_RAW;
		meshDesc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_GPU_ONLY;
		meshDesc.mDesc.mFlags = ::BUFFER_CREATION_FLAG_SHADER_DEVICE_ADDRESS;
		meshDesc.mDesc.mSize = sizeof(GPUMesh) * k_MaxMeshes;
		meshDesc.mDesc.mElementCount = (uint32_t)(meshDesc.mDesc.mSize / sizeof(uint32_t));
		meshDesc.mDesc.bBindless = true;
		meshDesc.pData = appState->meshes;
		meshDesc.ppBuffer = &appState->meshesBuffer;
		meshDesc.mDesc.pName = "Mesh Buffer";
		::addResource(&meshDesc, NULL);

		::BufferLoadDesc vbDesc = {};
		vbDesc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_BUFFER_RAW;
		vbDesc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_GPU_ONLY;
		vbDesc.mDesc.mFlags = ::BUFFER_CREATION_FLAG_SHADER_DEVICE_ADDRESS;
		vbDesc.mDesc.mSize = sizeof(MeshVertex) * appState->geometry.numVertices;
		vbDesc.mDesc.mElementCount = (uint32_t)(vbDesc.mDesc.mSize / sizeof(uint32_t));
		vbDesc.mDesc.bBindless = true;
		vbDesc.pData = appState->geometry.vertices;
		vbDesc.ppBuffer = &appState->vertexBuffer;
		vbDesc.mDesc.pName = "Vertex Buffer";
		::addResource(&vbDesc, NULL);

		::BufferLoadDesc ibDesc = {};
		ibDesc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_INDEX_BUFFER;
		ibDesc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_GPU_ONLY;
		ibDesc.mDesc.mSize = sizeof(uint32_t) * appState->geometry.numIndices;
		ibDesc.pData = appState->geometry.indices;
		ibDesc.ppBuffer = &appState->indexBuffer;
		::addResource(&ibDesc, NULL);
	}
}

void renderer_RemoveGeometry(AppState* appState)
{
	::removeResource(appState->meshesBuffer);
	::removeResource(appState->vertexBuffer);
	::removeResource(appState->indexBuffer);

	tf_free(appState->geometry.indices);
	tf_free(appState->geometry.vertices);
	tf_free(appState->meshes);

	k_ScratchGeometryData.destroy();
}

static inline void loadMat4(const ::mat4& matrix, float* output)
{
	output[0] = matrix.getCol(0).getX();
	output[1] = matrix.getCol(0).getY();
	output[2] = matrix.getCol(0).getZ();
	output[3] = matrix.getCol(0).getW();
	output[4] = matrix.getCol(1).getX();
	output[5] = matrix.getCol(1).getY();
	output[6] = matrix.getCol(1).getZ();
	output[7] = matrix.getCol(1).getW();
	output[8] = matrix.getCol(2).getX();
	output[9] = matrix.getCol(2).getY();
	output[10] = matrix.getCol(2).getZ();
	output[11] = matrix.getCol(2).getW();
	output[12] = matrix.getCol(3).getX();
	output[13] = matrix.getCol(3).getY();
	output[14] = matrix.getCol(3).getZ();
	output[15] = matrix.getCol(3).getW();
}

int32_t mikkt_GetNumFaces(const SMikkTSpaceContext* context);
int32_t mikkt_GetNumVerticesOfFace(const SMikkTSpaceContext* context, int32_t faceIndex);
uint32_t mikkt_GetVertexIndex(const SMikkTSpaceContext* context, int32_t faceIndex, int32_t vertIndex);
void mikkt_GetPosition(const SMikkTSpaceContext* context, float position[3], int32_t faceIndex, int32_t vertIndex);
void mikkt_GetNormal(const SMikkTSpaceContext* context, float normal[3], int32_t faceIndex, int32_t vertIndex);
void mikkt_GetTexcoord(const SMikkTSpaceContext* context, float normal[2], int32_t faceIndex, int32_t vertIndex);
void mikkt_SetTSpaceBasic(const SMikkTSpaceContext* context, const float tangent[3], float sign, int32_t faceIndex, int32_t vertIndex);

struct MikkTUserData
{
	RendererGeometry* geometry;
};

void renderer_LoadMesh(RendererGeometry* geometry, const char* path, GPUMesh* mesh)
{
	k_ScratchGeometryData.initialize();
	k_ScratchGeometryData.reset();

	fastObjMesh* obj = fast_obj_read(path);
	if (!obj)
	{
		return;
	}

	size_t indexCount = 0;
	for (uint32_t i = 0; i < obj->face_count; ++i)
	{
		indexCount += 3 * (obj->face_vertices[i] - 2);
	}

	size_t vertexOffset = 0;
	size_t indexOffset = 0;

	for (uint32_t i = 0; i < obj->face_count; ++i)
	{
		assert(obj->face_vertices[i] == 3);

		for (uint32_t j = 0; j < obj->face_vertices[i]; ++j)
		{
			fastObjIndex gi = obj->indices[indexOffset + j];

			MeshVertex* v = &k_ScratchGeometryData.geometry.vertices[vertexOffset++];
			v->position.x = obj->positions[gi.p * 3 + 0];
			v->position.y = obj->positions[gi.p * 3 + 1];
			v->position.z = obj->positions[gi.p * 3 + 2];
			v->color.x = obj->colors[gi.p * 3 + 0];
			v->color.y = obj->colors[gi.p * 3 + 1];
			v->color.z = obj->colors[gi.p * 3 + 2];
			v->normal.x = obj->normals[gi.n * 3 + 0];
			v->normal.y = obj->normals[gi.n * 3 + 1];
			v->normal.z = obj->normals[gi.n * 3 + 2];
			v->uv.x = obj->texcoords[gi.t * 2 + 0];
			v->uv.y = 1.0f - obj->texcoords[gi.t * 2 + 1];
			v->tangent.x = 0;
			v->tangent.z = 0;
			v->tangent.y = 0;
			v->tangent.w = 0;
		}

		indexOffset += obj->face_vertices[i];
	}

	assert(vertexOffset == indexCount);
	k_ScratchGeometryData.geometry.numVertices = (uint32_t)indexCount;
	k_ScratchGeometryData.geometry.numIndices = (uint32_t)indexCount;

	for (uint32_t i = 0; i < indexCount; ++i) {
		k_ScratchGeometryData.geometry.indices[i] = (uint32_t)i;
	}

	// Calculate MikkTSpace tangents
	::SMikkTSpaceInterface mikktInterface = {};
	mikktInterface.m_getNumFaces = mikkt_GetNumFaces;
	mikktInterface.m_getNumVerticesOfFace = mikkt_GetNumVerticesOfFace;
	mikktInterface.m_getPosition = mikkt_GetPosition;
	mikktInterface.m_getNormal = mikkt_GetNormal;
	mikktInterface.m_getTexCoord = mikkt_GetTexcoord;
	mikktInterface.m_setTSpaceBasic = mikkt_SetTSpaceBasic;

	::SMikkTSpaceContext mikktContext = {};
	mikktContext.m_pInterface = &mikktInterface;
	mikktContext.m_pUserData = (void*)&k_ScratchGeometryData.geometry;

	::genTangSpaceDefault(&mikktContext);

	fast_obj_destroy(obj);

	// TODO: Regenerate the index buffer with meshoptimizer

	for (uint32_t i = 0; i < k_ScratchGeometryData.geometry.numVertices; ++i)
	{
		geometry->vertices[geometry->numVertices + i] = k_ScratchGeometryData.geometry.vertices[i];
	}

	for (uint32_t i = 0; i < k_ScratchGeometryData.geometry.numIndices; ++i) {
		geometry->indices[geometry->numIndices + i] = k_ScratchGeometryData.geometry.indices[i];
	}

	mesh->indexOffset = geometry->numIndices;
	mesh->vertexOffset = geometry->numVertices;
	mesh->indexCount = k_ScratchGeometryData.geometry.numIndices;

	geometry->numVertices += k_ScratchGeometryData.geometry.numVertices;
	geometry->numIndices += k_ScratchGeometryData.geometry.numIndices;

	return;
}

bool ScratchGeometryData::isInitialized()
{
	return geometry.vertices != NULL && geometry.indices != NULL;
}

void ScratchGeometryData::initialize()
{
	if (isInitialized()) return;
	assert(maxVertices > 0);
	assert(maxIndices > 0);

	geometry.vertices = (MeshVertex*)tf_malloc(sizeof(MeshVertex) * maxVertices);
	geometry.indices = (uint32_t*)tf_malloc(sizeof(uint32_t) * maxIndices);
	reset();
}

void ScratchGeometryData::reset()
{
	assert(maxVertices > 0);
	assert(maxIndices > 0);

	assert(geometry.vertices);
	memset(geometry.vertices, 0, sizeof(MeshVertex) * maxVertices);
	geometry.numVertices = 0;

	assert(geometry.indices);
	memset(geometry.indices, 0, sizeof(uint32_t) * maxIndices);
	geometry.numIndices = 0;
}

void ScratchGeometryData::destroy()
{
	tf_free(geometry.vertices);
	tf_free(geometry.indices);
}

int32_t mikkt_GetNumFaces(const SMikkTSpaceContext* context)
{
	RendererGeometry* geometry = (RendererGeometry*)context->m_pUserData;
	return (int32_t)geometry->numIndices / 3;
}

int32_t mikkt_GetNumVerticesOfFace(const SMikkTSpaceContext* context, int32_t faceIndex)
{
	(void)context;
	(void)faceIndex;

	return 3;
}

uint32_t mikkt_GetVertexIndex(const SMikkTSpaceContext* context, int32_t faceIndex, int32_t vertIndex)
{
	RendererGeometry* geometry = (RendererGeometry*)context->m_pUserData;

	uint32_t index = faceIndex * 3 + vertIndex;
	assert(index < geometry->numIndices);

	uint32_t vertexIndex = geometry->indices[index];
	assert(vertexIndex < geometry->numVertices);

	return vertexIndex;
}

void mikkt_GetPosition(const SMikkTSpaceContext* context, float position[3], int32_t faceIndex, int32_t vertIndex)
{
	RendererGeometry* geometry = (RendererGeometry*)context->m_pUserData;

	uint32_t vertexIndex = mikkt_GetVertexIndex(context, faceIndex, vertIndex);
	const MeshVertex& vertex = geometry->vertices[vertexIndex];
	position[0] = vertex.position.x;
	position[1] = vertex.position.y;
	position[2] = vertex.position.z;
}

void mikkt_GetNormal(const SMikkTSpaceContext* context, float normal[3], int32_t faceIndex, int32_t vertIndex)
{
	RendererGeometry* geometry = (RendererGeometry*)context->m_pUserData;

	uint32_t vertexIndex = mikkt_GetVertexIndex(context, faceIndex, vertIndex);
	const MeshVertex& vertex = geometry->vertices[vertexIndex];
	normal[0] = vertex.normal.x;
	normal[1] = vertex.normal.y;
	normal[2] = vertex.normal.z;
}

void mikkt_GetTexcoord(const SMikkTSpaceContext* context, float texcoord[2], int32_t faceIndex, int32_t vertIndex)
{
	RendererGeometry* geometry = (RendererGeometry*)context->m_pUserData;

	uint32_t vertexIndex = mikkt_GetVertexIndex(context, faceIndex, vertIndex);
	const MeshVertex& vertex = geometry->vertices[vertexIndex];
	texcoord[0] = vertex.uv.x;
	texcoord[1] = vertex.uv.y;
}

void mikkt_SetTSpaceBasic(const SMikkTSpaceContext* context, const float tangent[3], float sign, int32_t faceIndex, int32_t vertIndex)
{
	RendererGeometry* geometry = (RendererGeometry*)context->m_pUserData;

	uint32_t vertexIndex = mikkt_GetVertexIndex(context, faceIndex, vertIndex);
	MeshVertex& vertex = geometry->vertices[vertexIndex];
	vertex.tangent.x = tangent[0];
	vertex.tangent.y = tangent[1];
	vertex.tangent.z = tangent[2];
	vertex.tangent.w = sign;
}