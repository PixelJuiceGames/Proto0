#include <assert.h>

// SDL3

#define SDL_MAIN_USE_CALLBACKS 1
#include <SDL3/SDL.h>
#include <SDL3/SDL_main.h>

// fast_obj

#define FAST_OBJ_IMPLEMENTATION
#include <fast_obj.h>

// The-Forge

#include <Graphics/Interfaces/IGraphics.h>
#include <Utilities/Interfaces/IFileSystem.h>
#include <Utilities/Interfaces/ILog.h>
#include <Utilities/Interfaces/IMemory.h>
#include <Utilities/RingBuffer.h>

// Shader Interop

#include <ShaderGlobals.h>

static inline void loadMat4(const ::mat4& matrix, float* output);

struct Timer
{
	uint64_t lastTicks = 0;
	float deltaTime = 0.0f;

	void Tick()
	{
		uint64_t ticks = SDL_GetTicksNS();
		uint64_t deltaNS = ticks - lastTicks;
		deltaTime = (float)(deltaNS * 1e-9);
		lastTicks = ticks;
	}
};

struct OrbitCamera
{
	::mat4 viewMatrix;
	::float3 position;
	::float3 lookAt;
	
	::float3 getViewDir()
	{
		::mat4 transposed = ::transpose(viewMatrix);
		::Vector4 forward = -transposed.getCol2();
		return { forward.getX(), forward.getY(), forward.getZ() };
	}

	void updateViewMatrix()
	{
		viewMatrix = ::mat4::lookAtRH({ position.x, position.y, position.z }, { lookAt.x, lookAt.y, lookAt.z }, {0.0f, 0.0f, 1.0f});
	}
};

// TODO: These should be autogenerated with some codegen solution
// from the shader (source of bytecode reflections) 
// UberShader Descriptor Sets
struct SRT_UberShaderData
{
	struct Persistent
	{
		const ::Descriptor gLinearRepeatSampler =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gLinearRepeatSampler", ROOT_PARAM_Persistent_SAMPLER,
#endif
			::DESCRIPTOR_TYPE_SAMPLER, 1, 0
		};
	}* pPersistent;

	static const ::Descriptor* PersistentPtr()
	{
		if (!sizeof(Persistent))
		{
			return 0;
		}

		static Persistent layout = {};
		::Descriptor* desc = (::Descriptor*)((uint64_t)&layout);
		return &desc[0];
	}

	struct PerFrame
	{
		const ::Descriptor CB0 =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"CB0", ROOT_PARAM_PerFrame, 
#endif
			::DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1, 0
		};
	}* pPerFrame;

	static const ::Descriptor* PerFramePtr()
	{
		if (!sizeof(PerFrame))
		{
			return 0;
		}

		static PerFrame layout = {};
		::Descriptor* desc = (::Descriptor*)((uint64_t)&layout);
		return &desc[0];
	}
};

// TODO: These should be autogenerated with some codegen solution
// from the shader (source of bytecode reflections) 
// Tone Mapping Descriptor Sets
struct SRT_ToneMappingData
{
	struct Persistent
	{
		const ::Descriptor gLinearClampSampler =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gLinearClampSampler", ROOT_PARAM_Persistent_SAMPLER,
#endif
			::DESCRIPTOR_TYPE_SAMPLER, 1, 0
		};
	}*pPersistent;

	static const ::Descriptor* PersistentPtr()
	{
		if (!sizeof(Persistent))
		{
			return 0;
		}

		static Persistent layout = {};
		::Descriptor* desc = (::Descriptor*)((uint64_t)&layout);
		return &desc[0];
	}

	struct PerFrame
	{
		const ::Descriptor gSceneColor =
		{
#if defined IF_VALIDATE_DESCRIPTOR
			"gSceneColor", ROOT_PARAM_PerFrame,
#endif
			::DESCRIPTOR_TYPE_TEXTURE, 1, 0
		};
	}*pPerFrame;

	static const ::Descriptor* PerFramePtr()
	{
		if (!sizeof(PerFrame))
		{
			return 0;
		}

		static PerFrame layout = {};
		::Descriptor* desc = (::Descriptor*)((uint64_t)&layout);
		return &desc[0];
	}
};

struct RendererGeometry
{
	MeshVertex* vertices = NULL;
	uint32_t* indices = NULL;

	uint32_t numVertices = 0;
	uint32_t numIndices = 0;
};

const uint32_t gDataBufferCount = 2;

struct AppState
{
	SDL_Window* window = NULL;

	uint32_t frameIndex = 0;

	::Renderer* renderer = NULL;
	::Queue* graphicsQueue = NULL;
	::GpuCmdRing graphicsCmdRing = {};
	::SwapChain* swapChain = NULL;
	::Semaphore* imageAcquiredSemaphore = NULL;
	::RenderTarget* sceneColor = NULL;
	::RenderTarget* depthBuffer = NULL;

	RendererGeometry geometry = {};
	::Buffer* vertexBuffer = NULL;
	::Buffer* indexBuffer = NULL;

	::Buffer* frameUniformBuffers[gDataBufferCount] = { NULL };
	::Buffer* instanceBuffers[gDataBufferCount] = { NULL };
	::Buffer* materialBuffers[gDataBufferCount] = { NULL };

	GPUInstance* instances = NULL;
	uint32_t numInstances = 0;

	GPUMaterial* materials = NULL;
	uint32_t numMaterials = 0;

	// UberShader
	::Shader* uberShader = NULL;
	::Pipeline* uberPipeline = NULL;

	// Tonemapping
	::Shader* toneMapping = NULL;
	::Pipeline* toneMappingPipeline = NULL;
	::DescriptorSet* toneMappingPersistentDescriptorSet = NULL;
	::DescriptorSet* toneMappingPerFrameDescriptorSet = NULL;

	::Sampler* linearRepeatSampler = NULL;
	::Sampler* linearClampSampler = NULL;

	// NOTE: This is the data of a specific material
	::DescriptorSet* uberPersistentDescriptorSet = NULL;
	::DescriptorSet* uberPerFrameDescriptorSet = NULL;
	::Texture* albedoTexture = NULL;
	::Texture* normalTexture = NULL;
	::Texture* ormTexture = NULL;
	::Texture* emissiveTexture = NULL;

	// Timer
	Timer timer;

	// Orbit camera data
	OrbitCamera orbitCamera;
	bool cameraDragging = false;
	::float2 lastMousePosition;
};

bool renderer_Initialize(AppState* appState);
void renderer_Exit(AppState* appState);
bool renderer_OnLoad(AppState* appState, ReloadDesc reloadDesc);
void renderer_OnUnload(AppState* appState, ReloadDesc reloadDesc);
bool renderer_AddSwapChain(AppState* appState);
void renderer_RemoveSwapChain(AppState* appState);
bool renderer_AddRenderTargets(AppState* appState);
void renderer_RemoveRenderTargets(AppState* appState);
void renderer_Draw(AppState* appState);
void renderer_LoadGeometry(RendererGeometry* geometry, const char* path);
void renderer_AddShaders(AppState* appState);
void renderer_RemoveShaders(AppState* appState);
void renderer_AddDescriptorSets(AppState* appState);
void renderer_PrepareDescriptorSets(AppState* appState);
void renderer_RemoveDescriptorSets(AppState* appState);
void renderer_AddPipelines(AppState* appState);
void renderer_RemovePipelines(AppState* appState);

SDL_AppResult SDL_AppInit(void** appstate, int argc, char* argv[])
{
	AppState* as = (AppState*)SDL_calloc(1, sizeof(AppState));
	if (!as)
	{
		return SDL_APP_FAILURE;
	}

	memset(as, 0, sizeof(AppState));

	*appstate = as;
	as->orbitCamera.position = { 0.0f, -5.0f, 0.0f };
	as->orbitCamera.lookAt = { 0.0f, 0.0f, 0.0f };
	as->orbitCamera.updateViewMatrix();

	as->window = SDL_CreateWindow("Prototype 0", 1920, 1080, SDL_WINDOW_RESIZABLE);
	if (!as->window)
	{
		SDL_Log("Couldn't create window: %s", SDL_GetError());
		return SDL_APP_FAILURE;
	}

	if (!renderer_Initialize(as))
	{
		return SDL_APP_FAILURE;
	}
	
	SDL_Log("Initialized");
	return SDL_APP_CONTINUE;
}

SDL_AppResult SDL_AppEvent(void* appstate, SDL_Event* event)
{
    if (event->type == SDL_EVENT_QUIT)
    {
        return SDL_APP_SUCCESS;
    }

	AppState* as = (AppState*)appstate;
	if (event->type == SDL_EVENT_MOUSE_BUTTON_DOWN)
	{
		if (event->button.button == SDL_BUTTON_LEFT)
		{
			if (!as->cameraDragging)
			{
				as->cameraDragging = true;
			}
		}
	}

	if (event->type == SDL_EVENT_MOUSE_BUTTON_UP)
	{
		if (event->button.button == SDL_BUTTON_LEFT)
		{
			as->cameraDragging = false;
		}
	}

	if (event->type == SDL_EVENT_WINDOW_RESIZED)
	{
		renderer_OnUnload(as, { ::RELOAD_TYPE_RESIZE });
		renderer_OnLoad(as, { ::RELOAD_TYPE_RESIZE });
	}

	if (event->type == SDL_EVENT_KEY_DOWN)
	{
		if (event->key.key == SDLK_R)
		{
			renderer_OnUnload(as, { ::RELOAD_TYPE_SHADER });
			renderer_OnLoad(as, { ::RELOAD_TYPE_SHADER });
		}
	}

    return SDL_APP_CONTINUE;
}

SDL_AppResult SDL_AppIterate(void* appstate)
{
	AppState* as = (AppState*)appstate;
	as->timer.Tick();

	if (as->cameraDragging)
	{

#if 0
		int32_t windowWidth;
		int32_t windowHeight;
		SDL_GetWindowSizeInPixels(as->window, &windowWidth, &windowHeight);

		float xPos;
		float yPos;
		SDL_MouseButtonFlags mouseButtonFlags = SDL_GetMouseState(&xPos, &yPos);

		float deltaAngleX = (2.0f * PI / (float)windowWidth);
		float deltaAngleY = (PI / (float)windowHeight);

		::float3 cameraViewDir = as->orbitCamera.getViewDir();
		::Vector3 viewDir = { cameraViewDir.x, cameraViewDir.y, cameraViewDir.z };
		::Vector3 upDir = { 0.0f, 0.0f, 1.0f };
		float cosAngle = ::dot(viewDir, upDir);
		if (cosAngle * ::sign(cosAngle) > 0.99f)
		{
			deltaAngleY = 0.0f;
		}

		float xAngle = (as->lastMousePosition.x - xPos) * deltaAngleX * 10.0f * as->timer.deltaTime;
		float yAngle = (as->lastMousePosition.y - yPos) * deltaAngleY * 10.0f * as->timer.deltaTime;

		::Vector4 cameraPosition = { as->orbitCamera.position.x, as->orbitCamera.position.y, as->orbitCamera.position.z, 1.0f };

		::mat4 rotationX = ::mat4::rotationX(yAngle);
		cameraPosition = rotationX * cameraPosition;

		::mat4 rotationZ = ::mat4::rotationZ(xAngle);
		cameraPosition = rotationZ * cameraPosition;
#else
		::Vector4 cameraPosition = { as->orbitCamera.position.x, as->orbitCamera.position.y, as->orbitCamera.position.z, 1.0f };

		float rotationAngle = as->timer.deltaTime;
		if (rotationAngle > 2.0f * PI) {
			rotationAngle = 0.0f;
		}
		::mat4 rotationZ = ::mat4::rotationZ(rotationAngle);
		cameraPosition = rotationZ * cameraPosition;
#endif

		as->orbitCamera.position = { cameraPosition.getX(), cameraPosition.getY(), cameraPosition.getZ() };
		as->orbitCamera.updateViewMatrix();

#if 0
		as->lastMousePosition.x = xPos;
		as->lastMousePosition.y = yPos;
#endif
	}

	renderer_Draw(as);

    return SDL_APP_CONTINUE;
}

void SDL_AppQuit(void* appstate, SDL_AppResult result)
{
	if (appstate != NULL)
	{
		AppState* as = (AppState*)appstate;
		renderer_Exit(as);

		SDL_free(as);
	}
}

bool renderer_Initialize(AppState* appState)
{
	if (!appState)
	{
		SDL_Log("AppState has not been initialized");
		return false;
	}

	// Initialize Memory Allocation System
	{
		if (!::initMemAlloc("Prototype 0"))
		{
			SDL_Log("Couldn't initialize The-Forge Memory Allocation system");
			return false;
		}
	}

	// Initialize The-Forge File System
	{
		FileSystemInitDesc desc = FileSystemInitDesc{};
		desc.pAppName = "Prototype 0";
		if (!::initFileSystem(&desc))
		{
			SDL_Log("Couldn't initialize The-Forge File system");
			return false;
		}
	}

	// Initialize The-Forge Logging System
	{
		::initLog("Prototype 0", LogLevel::eALL);
	}

	// Initialize The-Forge Renderer
	{
		::RendererDesc desc = RendererDesc{};
		memset((void*)&desc, 0, sizeof(RendererDesc));
		::initGPUConfiguration(desc.pExtendedSettings);

		::initRenderer("Prototype 0", &desc, &appState->renderer);
		if (!appState->renderer)
		{
			SDL_Log("Couldn't initialize The-Forge Renderer");
			return false;
		}

		::setupGPUConfigurationPlatformParameters(appState->renderer, desc.pExtendedSettings);
	}

	// Initialize Graphics Queue
	{
		::QueueDesc queueDesc = {};
		queueDesc.mType = ::QUEUE_TYPE_GRAPHICS;
		queueDesc.mFlag = ::QUEUE_FLAG_INIT_MICROPROFILE;
		::initQueue(appState->renderer, &queueDesc, &appState->graphicsQueue);

		::GpuCmdRingDesc cmdRingDesc = {};
		cmdRingDesc.pQueue = appState->graphicsQueue;
		cmdRingDesc.mPoolCount = gDataBufferCount;
		cmdRingDesc.mCmdPerPoolCount = 1;
		cmdRingDesc.mAddSyncPrimitives = true;
		::initGpuCmdRing(appState->renderer, &cmdRingDesc, &appState->graphicsCmdRing);

		::initSemaphore(appState->renderer, &appState->imageAcquiredSemaphore);
	}

	::initResourceLoaderInterface(appState->renderer);

	::RootSignatureDesc rootDesc = {};
	rootDesc.pGraphicsFileName = "DefaultRootSignature.rs";
	::initRootSignature(appState->renderer, &rootDesc);

	// Static samplers
	{
		::SamplerDesc samplerDesc = {
			::FILTER_LINEAR,
			::FILTER_LINEAR,
			::MIPMAP_MODE_LINEAR,
			::ADDRESS_MODE_REPEAT,
			::ADDRESS_MODE_REPEAT,
			::ADDRESS_MODE_REPEAT,
		};
		::addSampler(appState->renderer, &samplerDesc, &appState->linearRepeatSampler);

		samplerDesc.mAddressU = ::ADDRESS_MODE_CLAMP_TO_EDGE;
		samplerDesc.mAddressV = ::ADDRESS_MODE_CLAMP_TO_EDGE;
		samplerDesc.mAddressW = ::ADDRESS_MODE_CLAMP_TO_EDGE;
		::addSampler(appState->renderer, &samplerDesc, &appState->linearClampSampler);
	}

	//
	{
		::BufferLoadDesc ubDesc = {};
		ubDesc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_UNIFORM_BUFFER;
		ubDesc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_CPU_TO_GPU;
		ubDesc.mDesc.mFlags = ::BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT;
		ubDesc.mDesc.pName = "Frame Uniform Buffer";
		ubDesc.mDesc.mSize = sizeof(Frame);
		ubDesc.pData = NULL;
		for (uint32_t i = 0; i < gDataBufferCount; ++i)
		{
			ubDesc.ppBuffer = &appState->frameUniformBuffers[i];
			::addResource(&ubDesc, NULL);
		}
	}

	// Temporary instances and materials
	{
		// Materials
		{
			// Load PBR Textures
			{
				::SyncToken texturesToken = NULL;

				::TextureLoadDesc textureLoadDesc = {};
				memset(&textureLoadDesc, 0, sizeof(::TextureLoadDesc));

				::TextureDesc textureDesc = {};
				memset(&textureDesc, 0, sizeof(::TextureDesc));
				textureDesc.bBindless = true;
				textureLoadDesc.pDesc = &textureDesc;

				textureLoadDesc.pFileName = "Models/DamagedHelmet_albedo.dds";
				textureLoadDesc.ppTexture = &appState->albedoTexture;
				::addResource(&textureLoadDesc, &texturesToken);

				textureLoadDesc.pFileName = "Models/DamagedHelmet_normal.dds";
				textureLoadDesc.ppTexture = &appState->normalTexture;
				::addResource(&textureLoadDesc, &texturesToken);

				textureLoadDesc.pFileName = "Models/DamagedHelmet_orm.dds";
				textureLoadDesc.ppTexture = &appState->ormTexture;
				::addResource(&textureLoadDesc, &texturesToken);

				textureLoadDesc.pFileName = "Models/DamagedHelmet_emissive.dds";
				textureLoadDesc.ppTexture = &appState->emissiveTexture;
				::addResource(&textureLoadDesc, &texturesToken);

				::waitForToken(&texturesToken);
			}

			appState->numMaterials = 1;
			appState->materials = (GPUMaterial*)SDL_malloc(sizeof(GPUMaterial) * appState->numMaterials);
			assert(appState->materials);
			memset(appState->materials, 0, sizeof(GPUMaterial) * appState->numMaterials);

			GPUMaterial& material = appState->materials[0];
			material.baseColor = { 1.0f, 1.0f, 1.0f, 1.0f };
			material.albedoTextureIndex = appState->albedoTexture->mDx.mDescriptors;
			material.normalTextureIndex = appState->normalTexture->mDx.mDescriptors;
			material.ormTextureIndex = appState->ormTexture->mDx.mDescriptors;
			material.emissiveTextureIndex = appState->emissiveTexture->mDx.mDescriptors;

			::BufferLoadDesc desc = {};
			desc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_BUFFER_RAW;
			desc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_GPU_ONLY;
			desc.mDesc.mFlags = ::BUFFER_CREATION_FLAG_SHADER_DEVICE_ADDRESS;
			desc.mDesc.mSize = sizeof(GPUMaterial) * appState->numMaterials;
			desc.mDesc.mElementCount = desc.mDesc.mSize / sizeof(uint32_t);
			desc.mDesc.bBindless = true;
			desc.pData = appState->materials;
			desc.mDesc.pName = "Materials Buffer";
			for (uint32_t i = 0; i < gDataBufferCount; ++i)
			{
				desc.ppBuffer = &appState->materialBuffers[i];
				::addResource(&desc, NULL);
			}
		}

		// Instances
		{
			appState->numInstances = 1;
			appState->instances = (GPUInstance*)SDL_malloc(sizeof(GPUInstance) * appState->numInstances);
			assert(appState->instances);
			memset(appState->instances, 0, sizeof(GPUInstance) * appState->numInstances);

			GPUInstance& instance = appState->instances[0];
			::mat4 identity = ::mat4::identity();
			loadMat4(identity, &instance.worldMat.m[0]);
			instance.materialBufferOffset = 0;

			::BufferLoadDesc desc = {};
			desc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_BUFFER_RAW;
			desc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_GPU_ONLY;
			desc.mDesc.mFlags = ::BUFFER_CREATION_FLAG_SHADER_DEVICE_ADDRESS;
			desc.mDesc.mSize = sizeof(GPUInstance) * appState->numInstances;
			desc.mDesc.mElementCount = desc.mDesc.mSize / sizeof(uint32_t);
			desc.mDesc.bBindless = true;
			desc.pData = appState->instances;
			desc.mDesc.pName = "Instances Buffer";
			for (uint32_t i = 0; i < gDataBufferCount; ++i)
			{
				desc.ppBuffer = &appState->instanceBuffers[i];
				::addResource(&desc, NULL);
			}
		}
	}

	if (!renderer_OnLoad(appState, { ::RELOAD_TYPE_ALL }))
	{
		SDL_Log("Couldn't load renderer resources");
		return false;
	}

	const uint32_t maxVertices = 256 * 1024;
	const uint32_t maxIndices = 1024 * 1024;

	appState->geometry.vertices = (MeshVertex*)tf_malloc(sizeof(MeshVertex) * maxVertices);
	assert(appState->geometry.vertices);
	memset(appState->geometry.vertices, 0, sizeof(MeshVertex) * maxVertices);

	appState->geometry.indices = (uint32_t*)tf_malloc(sizeof(uint32_t) * maxIndices);
	assert(appState->geometry.indices);
	memset(appState->geometry.indices, 0, sizeof(uint32_t) * maxIndices);

	const char* axisCalibratorPath = "Content/Models/DamagedHelmet.obj";
	renderer_LoadGeometry(&appState->geometry, axisCalibratorPath);

	{
		::BufferLoadDesc vbDesc = {};
		vbDesc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_BUFFER_RAW;
		vbDesc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_GPU_ONLY;
		vbDesc.mDesc.mFlags = ::BUFFER_CREATION_FLAG_SHADER_DEVICE_ADDRESS;
		vbDesc.mDesc.mSize = sizeof(MeshVertex) * appState->geometry.numVertices;
		vbDesc.mDesc.mElementCount = vbDesc.mDesc.mSize / sizeof(uint32_t);
		vbDesc.mDesc.bBindless = true;
		vbDesc.pData = appState->geometry.vertices;
		vbDesc.ppBuffer = &appState->vertexBuffer;
		vbDesc.mDesc.pName = "Vertex Buffer";
		::addResource(&vbDesc, NULL);

		::BufferLoadDesc ibDesc = {};
		ibDesc.mDesc.mDescriptors = ::DESCRIPTOR_TYPE_INDEX_BUFFER;
		ibDesc.mDesc.mMemoryUsage = ::RESOURCE_MEMORY_USAGE_GPU_ONLY;
		ibDesc.mDesc.mSize = sizeof(uint32_t) * appState->geometry.numIndices;
		ibDesc.pData = appState->geometry.indices;
		ibDesc.ppBuffer = &appState->indexBuffer;
		::addResource(&ibDesc, NULL);
	}

	::waitForAllResourceLoads();

	return true;
}

void renderer_Exit(AppState* appState)
{
	if (!appState)
	{
		SDL_Log("AppState has not been initialized");
		return;
	}

	tf_free(appState->geometry.indices);
	tf_free(appState->geometry.vertices);

	SDL_free(appState->materials);
	SDL_free(appState->instances);

	renderer_OnUnload(appState, { ::RELOAD_TYPE_ALL });

	::exitRootSignature(appState->renderer);

	::removeResource(appState->albedoTexture);
	::removeResource(appState->normalTexture);
	::removeResource(appState->ormTexture);
	::removeResource(appState->emissiveTexture);

	::removeSampler(appState->renderer, appState->linearRepeatSampler);
	::removeSampler(appState->renderer, appState->linearClampSampler);

	::removeResource(appState->vertexBuffer);
	::removeResource(appState->indexBuffer);
	for (uint32_t i = 0; i < gDataBufferCount; ++i)
	{
		::removeResource(appState->frameUniformBuffers[i]);
		::removeResource(appState->materialBuffers[i]);
		::removeResource(appState->instanceBuffers[i]);
	}

	::exitGpuCmdRing(appState->renderer, &appState->graphicsCmdRing);
	::exitSemaphore(appState->renderer, appState->imageAcquiredSemaphore);
	::exitResourceLoaderInterface(appState->renderer);

	::exitQueue(appState->renderer, appState->graphicsQueue);

	::exitRenderer(appState->renderer);
	::exitGPUConfiguration();
	::exitLog();
	::exitFileSystem();
	::exitMemAlloc();
}

bool renderer_OnLoad(AppState* appState, ::ReloadDesc reloadDesc)
{
	assert(appState);
	assert(appState->renderer);

	if (reloadDesc.mType & ::RELOAD_TYPE_SHADER)
	{
		renderer_AddShaders(appState);
		renderer_AddDescriptorSets(appState);
	}

	if (reloadDesc.mType & (::RELOAD_TYPE_RESIZE | ::RELOAD_TYPE_RENDERTARGET))
	{
		if (!renderer_AddSwapChain(appState))
		{
			return false;
		}

		if (!renderer_AddRenderTargets(appState))
		{
			return false;
		}
	}

	if (reloadDesc.mType & (::RELOAD_TYPE_SHADER | ::RELOAD_TYPE_RENDERTARGET))
	{
		renderer_AddPipelines(appState);
	}

	renderer_PrepareDescriptorSets(appState);

	return true;
}

void renderer_OnUnload(AppState* appState, ReloadDesc reloadDesc)
{
	assert(appState);
	assert(appState->renderer);

	::waitQueueIdle(appState->graphicsQueue);

	if (reloadDesc.mType & (::RELOAD_TYPE_SHADER | ::RELOAD_TYPE_RENDERTARGET))
	{
		renderer_RemovePipelines(appState);
	}

	if (reloadDesc.mType & (::RELOAD_TYPE_RESIZE | ::RELOAD_TYPE_RENDERTARGET))
	{
		renderer_RemoveSwapChain(appState);
		renderer_RemoveRenderTargets(appState);
	}

	if (reloadDesc.mType & ::RELOAD_TYPE_SHADER)
	{
		renderer_RemoveDescriptorSets(appState);
		renderer_RemoveShaders(appState);
	}
}

bool renderer_AddSwapChain(AppState* appState)
{
	SDL_PropertiesID properties = SDL_GetWindowProperties(appState->window);
	void* hwnd = SDL_GetPointerProperty(properties, SDL_PROP_WINDOW_WIN32_HWND_POINTER, NULL);
	::WindowHandle windowHandle = { ::WINDOW_HANDLE_TYPE_WIN32, (HWND)hwnd };

	int32_t width;
	int32_t height;
	SDL_GetWindowSizeInPixels(appState->window, &width, &height);

	::SwapChainDesc desc = {};
	desc.mWindowHandle = windowHandle;
	desc.mPresentQueueCount = 1;
	desc.ppPresentQueues = &appState->graphicsQueue;
	desc.mWidth = (uint32_t)width;
	desc.mHeight = (uint32_t)height;
	desc.mImageCount = ::getRecommendedSwapchainImageCount(appState->renderer, &windowHandle);
	desc.mColorFormat = ::getSupportedSwapchainFormat(appState->renderer, &desc, ::COLOR_SPACE_SDR_SRGB);
	desc.mColorSpace = ::COLOR_SPACE_SDR_SRGB;
	desc.mEnableVsync = true;
	desc.mFlags = ::SWAP_CHAIN_CREATION_FLAG_NONE;
	::addSwapChain(appState->renderer, &desc, &appState->swapChain);

	return appState->swapChain != NULL;
}

void renderer_RemoveSwapChain(AppState* appState)
{
	::removeSwapChain(appState->renderer, appState->swapChain);
}

bool renderer_AddRenderTargets(AppState* appState)
{
	int32_t window_width;
	int32_t window_height;
	SDL_GetWindowSizeInPixels(appState->window, &window_width, &window_height);

	// Add Depth Buffer
	{
		::RenderTargetDesc desc = {};
		desc.mWidth = (uint32_t)window_width;
		desc.mHeight = (uint32_t)window_height;
		desc.mDepth = 1;
		desc.mArraySize = 1;
		desc.mClearValue.depth = 0.0f;
		desc.mClearValue.stencil = 0;
		desc.mFormat = ::TinyImageFormat_D32_SFLOAT;
		desc.mStartState = ::RESOURCE_STATE_DEPTH_WRITE;
		desc.mSampleCount = ::SAMPLE_COUNT_1;
		desc.mSampleQuality = 0;
		desc.mFlags = ::TEXTURE_CREATION_FLAG_ON_TILE;
		::addRenderTarget(appState->renderer, &desc, &appState->depthBuffer);

		if (!appState->depthBuffer)
		{
			LOGF(eERROR, "Failed to create depth buffer");
			return false;
		}
	}

	// Add Scene Color
	{
		::RenderTargetDesc desc = {};
		desc.mWidth = (uint32_t)window_width;
		desc.mHeight = (uint32_t)window_height;
		desc.mDepth = 1;
		desc.mArraySize = 1;
		desc.mClearValue = { 0.0f, 0.0f, 0.0f, 0.0f };
		desc.mFormat = ::TinyImageFormat_R16G16B16A16_SFLOAT;
		desc.mStartState = ::RESOURCE_STATE_SHADER_RESOURCE;
		desc.mSampleCount = ::SAMPLE_COUNT_1;
		desc.mSampleQuality = 0;
		desc.mFlags = ::TEXTURE_CREATION_FLAG_ON_TILE;
		::addRenderTarget(appState->renderer, &desc, &appState->sceneColor);

		if (!appState->sceneColor)
		{
			LOGF(eERROR, "Failed to create the scene color buffer");
			return false;
		}
	}

	return true;
}

void renderer_RemoveRenderTargets(AppState* appState)
{
	::removeRenderTarget(appState->renderer, appState->depthBuffer);
	::removeRenderTarget(appState->renderer, appState->sceneColor);
}

void renderer_Draw(AppState* appState)
{
	int32_t windowWidth;
	int32_t windowHeight;
	SDL_GetWindowSizeInPixels(appState->window, &windowWidth, &windowHeight);

	uint32_t swapChainImageIndex;
	::acquireNextImage(appState->renderer, appState->swapChain, appState->imageAcquiredSemaphore, NULL, &swapChainImageIndex);

	::RenderTarget* swapChainBuffer = appState->swapChain->ppRenderTargets[swapChainImageIndex];
	::GpuCmdRingElement elem = ::getNextGpuCmdRingElement(&appState->graphicsCmdRing, true, 1);

	// Stall if CPU is running 2 frames ahead of GPU
	::FenceStatus fenceStatus;
	::getFenceStatus(appState->renderer, elem.pFence, &fenceStatus);
	if (fenceStatus == ::FENCE_STATUS_INCOMPLETE)
		::waitForFences(appState->renderer, 1, &elem.pFence);

	::resetCmdPool(appState->renderer, elem.pCmdPool);

	::Cmd* cmd = elem.pCmds[0];
	::beginCmd(cmd);

	// Forward Pass
	{
		// Resource Barriers
		{
			::RenderTargetBarrier rtBarriers[] = {
				{ appState->sceneColor, ::RESOURCE_STATE_SHADER_RESOURCE, ::RESOURCE_STATE_RENDER_TARGET },
			};
			::cmdResourceBarrier(cmd, 0, NULL, 0, NULL, TF_ARRAY_COUNT(rtBarriers), rtBarriers);
		}

		// Binding Render Targets
		{
			BindRenderTargetsDesc bindRenderTargets = {};
			bindRenderTargets.mRenderTargetCount = 1;
			bindRenderTargets.mRenderTargets[0] = {};
			bindRenderTargets.mRenderTargets[0].pRenderTarget = appState->sceneColor;
			bindRenderTargets.mRenderTargets[0].mLoadAction = ::LOAD_ACTION_CLEAR;
			bindRenderTargets.mDepthStencil.mLoadAction = ::LOAD_ACTION_CLEAR;
			bindRenderTargets.mDepthStencil.pDepthStencil = appState->depthBuffer;
			::cmdBindRenderTargets(cmd, &bindRenderTargets);
		}

		::cmdSetViewport(cmd, 0.0f, 0.0f, (float)windowWidth, (float)windowHeight, 0.0f, 1.0f);
		::cmdSetScissor(cmd, 0, 0, (uint32_t)windowWidth, (uint32_t)windowHeight);

		// Render meshes
		{
			::mat4 projMat = ::mat4::perspectiveRH(1.0471f, windowHeight / (float)windowWidth, 100.0f, 0.01f);
			::mat4 projViewMat = projMat * appState->orbitCamera.viewMatrix;
			Frame frameData = {};
			loadMat4(projViewMat, &frameData.projViewMat.m[0]);
			frameData.vertexBufferIndex = (uint32_t)appState->vertexBuffer->mDx.mDescriptors;
			frameData.materialBufferIndex = (uint32_t)appState->materialBuffers[appState->frameIndex]->mDx.mDescriptors;
			frameData.instanceBufferIndex = (uint32_t)appState->instanceBuffers[appState->frameIndex]->mDx.mDescriptors;

			::BufferUpdateDesc desc = { appState->frameUniformBuffers[appState->frameIndex] };
			::beginUpdateResource(&desc);
			memcpy(desc.pMappedData, &frameData, sizeof(frameData));
			::endUpdateResource(&desc);

			const uint32_t vertexBufferStrides = sizeof(MeshVertex);
			::cmdBindPipeline(cmd, appState->uberPipeline);
			::cmdBindDescriptorSet(cmd, 0, appState->uberPersistentDescriptorSet);
			::cmdBindDescriptorSet(cmd, appState->frameIndex, appState->uberPerFrameDescriptorSet);
			::cmdBindIndexBuffer(cmd, appState->indexBuffer, ::INDEX_TYPE_UINT32, 0);
			::cmdDrawIndexed(cmd, appState->geometry.numIndices, 0, 0);
		}

		::cmdBindRenderTargets(cmd, NULL);
	}

	// Tone Mapping Pass
	{
		// Resource Barriers
		{
			::RenderTargetBarrier rtBarriers[] = {
				{ appState->sceneColor, ::RESOURCE_STATE_RENDER_TARGET, ::RESOURCE_STATE_SHADER_RESOURCE },
				{ swapChainBuffer, ::RESOURCE_STATE_PRESENT, ::RESOURCE_STATE_RENDER_TARGET },
			};
			::cmdResourceBarrier(cmd, 0, NULL, 0, NULL, TF_ARRAY_COUNT(rtBarriers), rtBarriers);
		}

		// Binding Render Targets
		{
			BindRenderTargetsDesc bindRenderTargets = {};
			bindRenderTargets.mRenderTargetCount = 1;
			bindRenderTargets.mRenderTargets[0] = {};
			bindRenderTargets.mRenderTargets[0].pRenderTarget = swapChainBuffer;
			bindRenderTargets.mRenderTargets[0].mLoadAction = ::LOAD_ACTION_CLEAR;
			::cmdBindRenderTargets(cmd, &bindRenderTargets);
		}

		::cmdSetViewport(cmd, 0.0f, 0.0f, (float)windowWidth, (float)windowHeight, 0.0f, 1.0f);
		::cmdSetScissor(cmd, 0, 0, (uint32_t)windowWidth, (uint32_t)windowHeight);

		::cmdBindPipeline(cmd, appState->toneMappingPipeline);
		::cmdBindDescriptorSet(cmd, 0, appState->toneMappingPersistentDescriptorSet);
		::cmdBindDescriptorSet(cmd, appState->frameIndex, appState->toneMappingPerFrameDescriptorSet);
		::cmdDraw(cmd, 3, 0);

		// Resource Barriers
		{
			::RenderTargetBarrier rtBarriers[] = {
				{ swapChainBuffer, ::RESOURCE_STATE_RENDER_TARGET, ::RESOURCE_STATE_PRESENT },
			};
			::cmdResourceBarrier(cmd, 0, NULL, 0, NULL, TF_ARRAY_COUNT(rtBarriers), rtBarriers);
		}

		::cmdBindRenderTargets(cmd, NULL);
	}

	::endCmd(cmd);

	::FlushResourceUpdateDesc flushUpdateDesc = {};
	flushUpdateDesc.mNodeIndex = 0;
	::flushResourceUpdates(&flushUpdateDesc);
	::Semaphore* waitSemaphores[2] = { flushUpdateDesc.pOutSubmittedSemaphore, appState->imageAcquiredSemaphore };

	::QueueSubmitDesc submitDesc = {};
	submitDesc.mCmdCount = 1;
	submitDesc.mSignalSemaphoreCount = 1;
	submitDesc.mWaitSemaphoreCount = TF_ARRAY_COUNT(waitSemaphores);
	submitDesc.ppCmds = &cmd;
	submitDesc.ppSignalSemaphores = &elem.pSemaphore;
	submitDesc.ppWaitSemaphores = waitSemaphores;
	submitDesc.pSignalFence = elem.pFence;
	::queueSubmit(appState->graphicsQueue, &submitDesc);

	::QueuePresentDesc presentDesc = {};
	presentDesc.mIndex = (uint8_t)swapChainImageIndex;
	presentDesc.mWaitSemaphoreCount = 1;
	presentDesc.pSwapChain = appState->swapChain;
	presentDesc.ppWaitSemaphores = &elem.pSemaphore;
	presentDesc.mSubmitDone = true;

	::queuePresent(appState->graphicsQueue, &presentDesc);

	appState->frameIndex = (appState->frameIndex + 1) % gDataBufferCount;
}

// TODO(gmodarelli): Use scratch vertex and index buffers and generate proper
// indices with mesh_optimizer
void renderer_LoadGeometry(RendererGeometry* geometry, const char* path)
{
	fastObjMesh* obj = fast_obj_read(path);
	if (!obj)
	{
		return;
	}

	size_t indexCount = 0;
	for (uint32_t i = 0; i < obj->face_count; ++i)
	{
		indexCount += 3 * (obj->face_vertices[i] - 2);
	}

	size_t vertexOffset = 0;
	size_t indexOffset = 0;

	for (uint32_t i = 0; i < obj->face_count; ++i)
	{
		assert(obj->face_vertices[i] == 3);

		for (uint32_t j = 0; j < obj->face_vertices[i]; ++j)
		{
			fastObjIndex gi = obj->indices[indexOffset + j];

			MeshVertex* v = &geometry->vertices[geometry->numVertices + vertexOffset++];
			v->position.x = obj->positions[gi.p * 3 + 0];
			v->position.y = obj->positions[gi.p * 3 + 1];
			v->position.z = obj->positions[gi.p * 3 + 2];
			v->color.x = obj->colors[gi.p * 3 + 0];
			v->color.y = obj->colors[gi.p * 3 + 1];
			v->color.z = obj->colors[gi.p * 3 + 2];
			v->normal.x = obj->normals[gi.n * 3 + 0];
			v->normal.y = obj->normals[gi.n * 3 + 1];
			v->normal.z = obj->normals[gi.n * 3 + 2];
			v->uv.x = obj->texcoords[gi.t * 2 + 0];
			v->uv.y = 1.0f - obj->texcoords[gi.t * 2 + 1];
		}

		indexOffset += obj->face_vertices[i];
	}

	assert(vertexOffset == indexCount);
	geometry->numVertices += (uint32_t)indexCount;

	for (uint32_t i = 0; i < indexCount; ++i) {
		geometry->indices[geometry->numIndices + i] = (uint32_t)i;
	}
	geometry->numIndices += (uint32_t)indexCount;

	fast_obj_destroy(obj);
	return;
}

void renderer_AddShaders(AppState* appState)
{
	// Uber Shader
	{
		ShaderLoadDesc uberShader = {};
		uberShader.mVert.pFileName = "Uber.vert";
		uberShader.mFrag.pFileName = "Uber.pixel";
		::addShader(appState->renderer, &uberShader, &appState->uberShader);
	}

	// Tone mapping
	{
		ShaderLoadDesc uberShader = {};
		uberShader.mVert.pFileName = "FullscreenTriangle.vert";
		uberShader.mFrag.pFileName = "Tonemap.pixel";
		::addShader(appState->renderer, &uberShader, &appState->toneMapping);
	}
}

void renderer_RemoveShaders(AppState* appState)
{
	::removeShader(appState->renderer, appState->uberShader);
	::removeShader(appState->renderer, appState->toneMapping);
}

void renderer_AddDescriptorSets(AppState* appState)
{
	// Uber Shader Descriptor Sets
	{
		::DescriptorSetDesc desc = {};
		desc.mIndex = ROOT_PARAM_Persistent_SAMPLER;
		desc.mMaxSets = 1;
		desc.mNodeIndex = 0;
		desc.mDescriptorCount = 1;
		desc.pDescriptors = SRT_UberShaderData::PersistentPtr();
		::addDescriptorSet(appState->renderer, &desc, &appState->uberPersistentDescriptorSet);
	}

	{
		::DescriptorSetDesc desc = {};
		desc.mIndex = ROOT_PARAM_PerFrame;
		desc.mMaxSets = gDataBufferCount;
		desc.mNodeIndex = 0;
		desc.mDescriptorCount = 1;
		desc.pDescriptors = SRT_UberShaderData::PerFramePtr();
		::addDescriptorSet(appState->renderer, &desc, &appState->uberPerFrameDescriptorSet);
	}

	// Tone Mapping Descriptor Sets
	{
		::DescriptorSetDesc desc = {};
		desc.mIndex = ROOT_PARAM_Persistent_SAMPLER;
		desc.mMaxSets = 1;
		desc.mNodeIndex = 0;
		desc.mDescriptorCount = 1;
		desc.pDescriptors = SRT_ToneMappingData::PersistentPtr();
		::addDescriptorSet(appState->renderer, &desc, &appState->toneMappingPersistentDescriptorSet);
	}

	{
		::DescriptorSetDesc desc = {};
		desc.mIndex = ROOT_PARAM_PerFrame;
		desc.mMaxSets = gDataBufferCount;
		desc.mNodeIndex = 0;
		desc.mDescriptorCount = 1;
		desc.pDescriptors = SRT_ToneMappingData::PerFramePtr();
		::addDescriptorSet(appState->renderer, &desc, &appState->toneMappingPerFrameDescriptorSet);
	}
}

void renderer_PrepareDescriptorSets(AppState* appState)
{
	// Uber Shader Descriptor Sets
	{
		DescriptorData uParams[1] = {};
		uParams[0].mIndex = (offsetof(SRT_UberShaderData::Persistent, gLinearRepeatSampler)) / sizeof(::Descriptor);
		uParams[0].ppSamplers = &appState->linearRepeatSampler;
		updateDescriptorSet(appState->renderer, 0, appState->uberPersistentDescriptorSet, 1, uParams);
	}

	for (uint32_t i = 0; i < gDataBufferCount; ++i)
	{
		DescriptorData uParams[1] = {};
		uParams[0].mIndex = (offsetof(SRT_UberShaderData::PerFrame, CB0)) / sizeof(::Descriptor);
		uParams[0].ppBuffers = &appState->frameUniformBuffers[i];
		updateDescriptorSet(appState->renderer, i, appState->uberPerFrameDescriptorSet, 1, uParams);
	}

	// Tone Mapping Descriptor Sets
	{
		DescriptorData uParams[1] = {};
		uParams[0].mIndex = (offsetof(SRT_ToneMappingData::Persistent, gLinearClampSampler)) / sizeof(::Descriptor);
		uParams[0].ppSamplers = &appState->linearClampSampler;
		updateDescriptorSet(appState->renderer, 0, appState->toneMappingPersistentDescriptorSet, 1, uParams);
	}

	for (uint32_t i = 0; i < gDataBufferCount; ++i)
	{
		DescriptorData uParams[1] = {};
		uParams[0].mIndex = (offsetof(SRT_ToneMappingData::PerFrame, gSceneColor)) / sizeof(::Descriptor);
		uParams[0].ppTextures = &appState->sceneColor->pTexture;
		updateDescriptorSet(appState->renderer, i, appState->toneMappingPerFrameDescriptorSet, 1, uParams);
	}
}

void renderer_RemoveDescriptorSets(AppState* appState)
{
	::removeDescriptorSet(appState->renderer, appState->uberPersistentDescriptorSet);
	::removeDescriptorSet(appState->renderer, appState->uberPerFrameDescriptorSet);
	::removeDescriptorSet(appState->renderer, appState->toneMappingPersistentDescriptorSet);
	::removeDescriptorSet(appState->renderer, appState->toneMappingPerFrameDescriptorSet);
}

void renderer_AddPipelines(AppState* appState)
{
	// Uber Shader Pipeline
	{
		::RasterizerStateDesc rasterizerStateDesc = {};
		rasterizerStateDesc.mCullMode = ::CULL_MODE_BACK;
		rasterizerStateDesc.mFrontFace = ::FRONT_FACE_CCW;

		::DepthStateDesc depthStateDesc = {};
		depthStateDesc.mDepthTest = true;
		depthStateDesc.mDepthWrite = true;
		depthStateDesc.mDepthFunc = ::CMP_GEQUAL;

		::TinyImageFormat colorFormats = { ::TinyImageFormat_R16G16B16A16_SFLOAT };

		::PipelineDesc desc = {};
		desc.mType = ::PIPELINE_TYPE_GRAPHICS;
		::GraphicsPipelineDesc& pipelineSettings = desc.mGraphicsDesc;
		pipelineSettings.mPrimitiveTopo = ::PRIMITIVE_TOPO_TRI_LIST;
		pipelineSettings.mRenderTargetCount = 1;
		pipelineSettings.pDepthState = &depthStateDesc;
		pipelineSettings.pColorFormats = &colorFormats;
		pipelineSettings.mSampleCount = ::SAMPLE_COUNT_1;
		pipelineSettings.mSampleQuality = 0;
		pipelineSettings.mDepthStencilFormat = appState->depthBuffer->mFormat;
		pipelineSettings.pShaderProgram = appState->uberShader;
		pipelineSettings.pVertexLayout = NULL;
		pipelineSettings.pRasterizerState = &rasterizerStateDesc;
		pipelineSettings.mVRFoveatedRendering = false;
		::addPipeline(appState->renderer, &desc, &appState->uberPipeline);
	}

	// Tone Mapping Pipeline
	{
		::RasterizerStateDesc rasterizerStateDesc = {};
		rasterizerStateDesc.mCullMode = ::CULL_MODE_NONE;

		::DepthStateDesc depthStateDesc = {};
		depthStateDesc.mDepthTest = false;
		depthStateDesc.mDepthWrite = false;

		::PipelineDesc desc = {};
		desc.mType = ::PIPELINE_TYPE_GRAPHICS;
		::GraphicsPipelineDesc& pipelineSettings = desc.mGraphicsDesc;
		pipelineSettings.mPrimitiveTopo = ::PRIMITIVE_TOPO_TRI_LIST;
		pipelineSettings.mRenderTargetCount = 1;
		pipelineSettings.pDepthState = &depthStateDesc;
		pipelineSettings.pColorFormats = &appState->swapChain->ppRenderTargets[0]->mFormat;
		pipelineSettings.mSampleCount = appState->swapChain->ppRenderTargets[0]->mSampleCount;
		pipelineSettings.mSampleQuality = appState->swapChain->ppRenderTargets[0]->mSampleQuality;
		pipelineSettings.mDepthStencilFormat = appState->depthBuffer->mFormat;
		pipelineSettings.pShaderProgram = appState->toneMapping;
		pipelineSettings.pVertexLayout = NULL;
		pipelineSettings.pRasterizerState = &rasterizerStateDesc;
		pipelineSettings.mVRFoveatedRendering = false;
		::addPipeline(appState->renderer, &desc, &appState->toneMappingPipeline);
	}
}

void renderer_RemovePipelines(AppState* appState)
{
	::removePipeline(appState->renderer, appState->uberPipeline);
	::removePipeline(appState->renderer, appState->toneMappingPipeline);
}

static inline void loadMat4(const ::mat4& matrix, float* output)
{
	output[0] = matrix.getCol(0).getX();
	output[1] = matrix.getCol(0).getY();
	output[2] = matrix.getCol(0).getZ();
	output[3] = matrix.getCol(0).getW();
	output[4] = matrix.getCol(1).getX();
	output[5] = matrix.getCol(1).getY();
	output[6] = matrix.getCol(1).getZ();
	output[7] = matrix.getCol(1).getW();
	output[8] = matrix.getCol(2).getX();
	output[9] = matrix.getCol(2).getY();
	output[10] = matrix.getCol(2).getZ();
	output[11] = matrix.getCol(2).getW();
	output[12] = matrix.getCol(3).getX();
	output[13] = matrix.getCol(3).getY();
	output[14] = matrix.getCol(3).getZ();
	output[15] = matrix.getCol(3).getW();
}